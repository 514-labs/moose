import { FileTree } from "nextra/components";
import { Python, TypeScript, Callout, LanguageSwitcher } from "../components";

# Workflow Orchestration

<LanguageSwitcher />
Moose workflows enable developers to automate sequences of tasks in a maintainable, reliable way. A workflow is a series of tasks that execute in order. Each workflow follows these conventions:

- Workflows live in folders inside the `/app/scripts` subdirectory, with the folder name being the workflow name.
- Tasks are scripts with numerical prefixes (e.g., <Python NodeType="span">`1.first_task.py`</Python><TypeScript NodeType="span">`1.firstTask.ts`</TypeScript>).
- Configuration is managed through `config.toml` files.

<Callout type="info" title="Powered by Temporal">
This workflow abstraction is powered by Temporal under the hood. You can use the Temporal GUI to monitor your workflow runs as they execute, providing extra debugging capabilities.
</Callout>

## Quickstart

To create a new workflow, run the following command:

<Python>
```bash filename="Terminal" copy
moose-cli workflow init example_workflow --tasks first_task,second_task
```
</Python>

<TypeScript>
```bash filename="Terminal" copy
npx moose-cli workflow init ExampleWorkflow --tasks firstTask,secondTask
```
</TypeScript>

## Workflow Structure

A typical workflow looks like this:

<Python>
<FileTree>
<FileTree.Folder name="app" open>
<FileTree.Folder name="scripts" open>
<FileTree.Folder name="example_workflow" open>
<FileTree.File name="1.first_task.py" />
<FileTree.File name="2.second_task.py" />
<FileTree.File name="config.toml" />
</FileTree.Folder>
</FileTree.Folder>
</FileTree.Folder>
</FileTree>
</Python>

<TypeScript>
<FileTree>
<FileTree.Folder name="app" open>
<FileTree.Folder name="scripts" open>
<FileTree.Folder name="ExampleWorkflow" open>
<FileTree.File name="1.firstTask.ts" />
<FileTree.File name="2.secondTask.ts" />
<FileTree.File name="config.toml" />
</FileTree.Folder>
</FileTree.Folder>
</FileTree.Folder>
</FileTree>
</TypeScript>

## Writing Workflow Tasks

<Python>

Tasks are Python functions decorated with `@task`. Each task can receive inputs and return outputs:

```python filename="app/scripts/example_workflow/1.first_task.py"
from moose_lib import task, Logger

@task
def first_task(data: dict):
    logger = Logger('first_task')
    logger.info(f'Received data: {data}')
    
    # Example operation: Increment a counter
    result = data.get("counter", 0) + 1
    
    return {
        "task": "first_task",
        "data": {
            "counter": result,
            "timestamp": datetime.now().isoformat()
        }
    }
```
</Python>

<TypeScript>

Tasks are defined as asynchronous functions (of type `TaskFunction`) that perform some operations and return an object with two key properties: `task` and `data`.

```typescript filename="app/scripts/example_workflow/1.firstTask.ts"
import { TaskFunction, TaskDefinition } from "@514labs/moose-lib";

interface FirstTaskInput {
    number: number;
    name: string;
}

const firstTask: TaskFunction = async (input: FirstTaskInput) => {
    
    const counter = input.number + 1;
    const greeting = `hello, ${input.name}!`;
    
    return {
        task: "firstTask",
        data: {
            counter: counter,
            greeting: greeting
        }
    };
};

export default createTask() => {
    return {
        task: firstTask,
    } as TaskDefinition;
};
```
</TypeScript>

## Data Flow Between Tasks

Tasks communicate through their return values. Each task can return a dictionary containing a `data` key. The contents of this `data` key are automatically passed as input parameters to the next task in the workflow.

- Only values inside the `data` object are passed to the next task.
- Supported data types inside `data` include basic types, containers, and JSON-serializable custom classes.

<Python>
```python filename="app/scripts/example_workflow/1.first_task.py"
@task
def first_task(data: dict):
    logger = Logger('first_task')
    logger.info(f'Received data: {data}')

    name = data.get("name", "no name")
    greeting = f"hello, {name}!"
    counter = 1


    return {
        "task": "first_task",
        "data": {
            "name": name,
            "greeting": greeting,
            "counter": counter
        }
    }
```
```python filename="app/scripts/example_workflow/2.second_task.py"
from moose_lib import task, Logger

@task
def second_task(data: dict):
    
    name = data.get("name", "no name")
    greeting = data.get("greeting", "no greeting")
    counter = data.get("counter", 0)

    name_length = len(name)
    expanded_greeting = f"{greeting} Your name is {name_length} characters long"
    
    return {
        "task": "second_task",
        "data": {
            "name": name,
            "greeting": expanded_greeting,
            "counter": counter,
            "name_length": name_length
        }
    }
```
</Python>

<TypeScript>
```typescript filename="app/scripts/ExampleWorkflow/1.firstTask.ts"
import { TaskFunction, TaskDefinition } from "@514labs/moose-lib";

interface FirstTaskInput {
    name: string;
}

const firstTask: TaskFunction = async (input: FirstTaskInput) => {
    
    const greeting = `hello, ${input.name}!`;
    
    return {
        task: "firstTask",
        data: {
            name: input.name,
            greeting: greeting,
            counter: 1
        }
    };
};

export default createTask() => {
    return {
        task: firstTask,
    } as TaskDefinition;
}; 
```
```typescript filename="app/scripts/example_workflow/2.secondTask.ts"
import { TaskFunction, TaskDefinition } from "@514labs/moose-lib";

interface SecondTaskInput {
    name: string;
    greeting: string;
    counter: number;
}

const secondTask: TaskFunction = async (input: SecondTaskInput) => {
    const nameLength = len(input.name)
    const expandedGreeting = f"{input.greeting} Your name is {nameLength} characters long";

    // Example operation: Double the counter value
    const counter = input.counter + 1;
    
    return {
        task: "secondTask",
        data: {
            name: input.name,
            greeting: expandedGreeting,
            counter: counter,
            nameLength: nameLength
        }
    };
};

export default createTask() => {
    return {
        task: secondTask,
    } as TaskDefinition;
};
```
</TypeScript>

## Workflow Configuration

Control workflow behavior through `config.toml`:
<Python>
```toml filename="app/scripts/example_workflow/config.toml"
name = "example_workflow" # Required. The name of the workflow.
timeout = "1h" # Optional. If not specified, the default timeout is 1 hour.
retries = 3 # Optional. If not specified, the default retry count is 3.
schedule = "0 12 * * *" # Optional. If not specified, the workflow will not be scheduled.
tasks = [first_task, second_task] # Required. The list of tasks to execute.
```
</Python>

<TypeScript filename="app/scripts/example_workflow/config.toml" >
```toml
name = "example_workflow" # Required. The name of the workflow.
timeout = "1h" # Required. The timeout for the workflow.
retries = 3 # Required. The number of retries for the workflow.
schedule = "0 12 * * *" # Optional. If not specified, the workflow will not be scheduled.
tasks = [firstTask, secondTask] # Required. The list of tasks to execute.
```
</TypeScript>

### Timeouts and Retries

The `timeout` and `retries` fields in `config.toml` are optional. If not specified, the default values are 1 hour and 3 retries, respectively.

- **Timeout**: If a workflow execution does not complete within the specified timeout period, it will be terminated and marked as failed. This ensures that workflows do not run indefinitely.
- **Retries**: If a workflow task fails due to an error, it will be retried up to the specified number of retries. This allows for transient errors to be automatically handled without manual intervention.

### Cron Scheduling Format

The schedule field in `config.toml` uses standard cron expression syntax.

```toml filename="app/scripts/example_workflow/config.toml"
schedule = "0 12 * * *" # Runs at 12:00 PM every day
```

Below are some example cron expressions along with their scheduling details:

| Cron Expression             | Description                                   |
|-----------------------------|-----------------------------------------------|
| <code>0 12 * * *</code>      | Runs at 12:00 PM every day                    |
| <code>0 0 * * 0</code>       | Runs at 12:00 AM every Sunday                 |
| <code>0 8 * * 1-5</code>      | Runs at 8:00 AM on weekdays (Monday to Friday)|
| <code>* * * * *</code>        | Runs every minute                             |

<Callout type="info" title="Cron Expression Visualizer">
Use an online cron expression visualizer like [crontab.guru](https://crontab.guru/) to help you understand how the cron expression will schedule your workflow.
</Callout>

## Triggering Workflows

In addition to supporting scheduled workflows, Moose also supports triggering workflows via CLI and API.

### CLI Trigger

<Python>
```bash filename="Terminal" copy
moose-cli workflow run workflow_name
```
</Python>

<TypeScript>
```bash filename="Terminal" copy
npx moose-cli workflow run workflow_name
```
</TypeScript>

### API Trigger

<Callout type="warning" title="Python Only">
This feature is not yet available for TypeScript.
</Callout>


<Python>
You can create an API to trigger workflows by using the `MooseClient` that is automatically instantiated and passed to your API route handler:

```python filename="app/apis/trigger_workflow.py"
from moose_lib import MooseClient
from pydantic import BaseModel, Field

class WorkflowParams(BaseModel):
    input_value: str = Field(default="default")

def run(client: MooseClient, params: WorkflowParams) -> dict:
    return client.workflows.execute(
        workflow="example_workflow",
        params={input_value: params.input_value}
    )
```

For more information on how to set up a Moose API, see the [Consumption API](/consumption-apis) documentation.
</Python>

<TypeScript>
This feature is coming soon.
</TypeScript>


## Error Handling

Moose provides multiple layers of error protection.

### Task-Level Errors

Moose automatically catches any runtime errors during task execution. Errors are logged for debugging, and the orchestrator will retry failed tasks according to the retry count in `config.toml`.

### Configuring Retry Behavior

<Python>
```python
from moose_lib import task, Logger

@task(retries=3) 
def first_task(data: dict):
    logger = Logger('first_task')
    logger.info(f'Processing {data}')
    
    return {
        "task": "first_task",
        "data": {
            "result": "Success",
            "timestamp": datetime.now().isoformat()
        }
    }
```
</Python>

<TypeScript>
```typescript filename="app/scripts/ExampleWorkflow/1.firstTask.ts" {16-18}
import { TaskFunction, TaskDefinition } from "@514labs/moose-lib";

const firstTask: TaskFunction = async () => {
    return {
        task: "firstTask",
        data: {
            result: "Success",
            timestamp: new Date().toISOString()
        }
    };
};

export default createTask((input?: object) => {
    return {
        task: firstTask,
        config: {
            retries: 3 // This is optional. If you don't explicitly set retries, it will default to 3. 
        }
    } as TaskDefinition;
});
```
</TypeScript>
### Terminating Workflows

To terminate a workflow before it has finished running, use the `workflow terminate` command.

<Python>
```bash
moose-cli workflow terminate <workflow_name>
```
</Python>

<TypeScript>
```bash
npx moose-cli workflow terminate <workflow_name>
```
</TypeScript>

<Callout type="warning" title="Terminating Workflows">
You cannot run the same workflow concurrently. Use the `terminate` command to stop the workflow before triggering it again.
</Callout>

### Workflow Status

You can check the status of a workflow by using the `moose-cli workflow status` command.

<Python>
```bash
moose-cli workflow status <workflow_name> [--verbose]
```
</Python>

<TypeScript>
```bash
npx moose-cli workflow status <workflow_name> [--verbose]
```
</TypeScript>

Adding the `--verbose` flag will provide more detailed information about the workflow's status, including task level inputs and outputs.
