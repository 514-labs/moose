import { Callout } from "@/components";

# Working with Database Tables

Tables are the foundation of Moose's data storage layer, designed to integrate with your entire data pipeline. They store data from your APIs and streams while powering your analytics queries for your downstream transformations, APIs, and more.

## Overview

Tables in Moose eliminate the tedious database administration tasks that typically interrupt your development flow:

```ts filename="FirstTable.ts" copy
interface MyFirstTable {
  id: Key<string>;
  name: string;
  age: number;
}

const myTable = new OlapTable<MyFirstTable>("my_first_table");
```

This simple interface definition is automatically converted into a ClickHouse table. No more context-switching between application code and database administration:

- **No SQL boilerplate**: Forget writing verbose CREATE TABLE and ALTER TABLE statements
- **Type-safe schema evolution**: Add fields to your model and tables update automatically
- **Automatic index creation**: Optimal indexes based on your key definitions
- **Type mapping handled for you**: Database types derived directly from your application types
- **Validation built-in**: Data is validated against your schema before storage

## Creating Tables

Tables in Moose provide a type-safe way to define your database schema directly in your code. There are two main approaches to creating tables:

### Standalone Tables

Create a table directly for custom data flows or when you need fine-grained control:

```ts filename="StandaloneTable.ts"
import { OlapTable, Key } from "@514labs/moose-lib";

// Define your schema
interface ExampleSchema {
  id: Key<string>;
  dateField: Date;
  numericField: number;
  booleanField: boolean;
  floatField: number;
  integerField: number & tags.Type<"int64">; // Moose supports native tagged types so you can use Integers in typescript
}

// Create a standalone table
const exampleTable = new OlapTable<ExampleSchema>("example_table", {
  orderByFields: ["id", "dateField"], // Optional when using a primary key
  deduplicate: true  // Optional: keep only the latest version of each record
});

// Now you can:
// - Write to this table from streams
// - Query it directly
// - Use it as a source for materialized views
```

### Tables in Ingestion Pipelines

For end-to-end data flows, create tables as part of an ingestion pipeline:

```ts filename="PipelineTable.ts"
import { IngestPipeline, Key } from "@514labs/moose-lib";

// Define your schema
interface UserEvent {
  id: Key<string>;
  userId: string;
  timestamp: Date;
  eventType: string;
  properties: object;
}

// Create a complete ingestion pipeline with a table
const eventsPipeline = new IngestPipeline<UserEvent>("user_events_pipeline", {
  ingest: true,    // Creates a REST API endpoint 
  stream: true,    // Creates Kafka/Redpanda topic
  table: {         // Creates and configures the table
    orderByFields: ["id", "timestamp"],
    deduplicate: true
  }
});

// Access the table component when needed
const eventsTable = eventsPipeline.table;
```

This integrated approach automatically creates the necessary infrastructure and connects all components, ensuring data flows smoothly from API to database with full type checking at every step.

## Querying Tables

Moose provides a `sql` tagged template literal function that you can use to write SQL queries on your tables, which supports interpolation of table names, column names, and values.

This is useful for:
- Transforming your data in your database and saving the results as regular views or [materialized views](/moose/materialized-views).
- Querying tables from your [Consumption API route handlers](/moose/consumption-api) to expose your data to client applications that are running outside of Moose.



```ts filename="QueryingTables.ts"
import { sql } from "@514labs/moose-lib";

interface MyTableSchema {
  id: Key<string>;
  name: string;
  value: number;
}

const myTable = new OlapTable<MyTableSchema>("my_table");

const query = sql`
  SELECT ${myTable.id}, ${myTable.name}, ${myTable.value} FROM ${myTable}
`;

// When Moose runs this query, it will automatically convert the interpolated values into the correct SQL syntax for your database:
// SELECT id, name, value FROM my_table
```

This lets you write SQL that feels like TypeScript - get autocomplete for your table columns and catch typos at dev time instead of waiting for runtime.

## Configuring Table Indexes

You must configure table indexing using one of these approaches:
1. Define at least one `Key` in your table schema
2. Specify `orderByFields` in the table config
3. Use both (all `Key` fields must come first in the `orderByFields` array)

```ts filename="PrimaryKeyConfig.ts"
import { OlapTable, Key } from '@514labs/moose-zlib';

// Approach 1: Using primary key only
interface Record1 {
  id: Key<string>;  // Primary key field
  field1: string;
  field2: number;
}

const table1 = new OlapTable<Record1>("table1");  // Uses id as orderByField automatically
```

### Order By Fields Only

```ts filename="OrderByFieldsOnly.ts"
// Approach 2: Using orderByFields only
interface SchemaWithoutPrimaryKey {
  field1: string;
  field2: number;
  field3: Date;
}

const tableWithOrderByFieldsOnly = new OlapTable<SchemaWithoutPrimaryKey>("table2", {
  orderByFields: ["field1", "field2"]  // Specify ordering without primary key
});
```

### Using Both Primary Key and Order By Fields
```ts filename="ComboKeyAndOrderByFields.ts"
// Approach 3: Using both (primary key must be first)
interface SchemaWithKey {
  id: Key<string>;  // Primary key field
  field1: string;
  field2: number;
}

const tableWithKeyAndOrderByFields = new OlapTable<SchemaWithKey>("table3", {
  orderByFields: ["id", "field1"]  // Primary key must be first
});
```

### Using Multiple Primary Keys
```ts filename="MultiKeyTable.ts"
interface MultiKeyRecord {
  key1: Key<string>;
  key2: Key<number>;
  field1: string;
}

const multiKeyTable = new OlapTable<MultiKeyRecord>("multi_key_table", {
  orderByFields: ["key1", "key2", "field1"]  // Multiple keys must come first
});
```

### Deduplication
Keep only the latest record per key:
```ts filename="DeduplicatedTable.ts"
const table = new OlapTable<Record>("table", {
  orderByFields: ["id"],
  deduplicate: true
});
```

<Callout type="warning" title="Deduplication Caveats">
Deduplication uses ClickHouse's ReplacingMergeTree engine for eventual deduplication, meaning duplicate records may not be removed immediately. This process can take time and is not guaranteed to be immediate. For more details, see the [ClickHouse documentation](https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/replacingmergetree).
</Callout>


### Invalid Configurations
```ts filename="InvalidConfig.ts"
// Error: No primary key or orderByFields
interface BadRecord1 {
  field1: string;
  field2: number;
}
const badTable1 = new OlapTable<BadRecord1>("bad_table1");

// Error: Primary key not first in orderByFields
interface BadRecord2 {
  id: Key<string>;
  field1: string;
}
const badTable2 = new OlapTable<BadRecord2>("bad_table2", {
  orderByFields: ["field1", "id"]  // Wrong order - primary key must be first
});

// Error: Nullable field in orderByFields
interface BadRecord3 {
  id: Key<string>;
  field1: string;
  field2?: number;
}
const badTable3 = new OlapTable<BadRecord3>("bad_table3", {
  orderByFields: ["id", "field2"]  // Can't have nullable field in orderByFields
});
```

### Best Practices
1. **Schema Design**
   - Use non-nullable fields for sorting/indexing
   - Make fields optional only when necessary
   - Consider query patterns when choosing `orderByFields`

2. **Performance**
   - Order fields based on common query patterns
   - Use deduplication for latest-version scenarios
   - Consider data volume for partitioning


## How It Works

When you create an `OlapTable` instance:
1. The table is registered in the global Moose registry
2. The schema is stored as JSON Schema (v3.1)
3. When deployed, Moose creates the corresponding infrastructure

## Development Workflow

### Local Development with Hot Reloading

One of the powerful features of Moose is its integration with the local development server:

1. Start your local development server with `moose dev`
2. When you define or modify an `OlapTable` in your code and save the file:
   - The changes are automatically detected
   - The TypeScript compiler plugin processes your schema definitions
   - The infrastructure is updated in real-time to match your code changes
   - Your tables are immediately available for testing

For example, if you add a new field to your schema:
```typescript
// Before
interface BasicSchema {
  id: Key<string>;
  name: string;
}

// After adding a field
interface BasicSchema {
  id: Key<string>;
  name: string;
  createdAt: Date;  // New field
}
```

The Moose framework will:
1. Detect the change when you save the file
2. Update the table schema in the local ClickHouse instance
3. Make the new field immediately available for use

### Verifying Your Tables

You can verify your tables were created correctly using:
```bash
# List all tables in your local environment
moose ls
```

Or by connecting directly to your local ClickHouse instance and running SQL commands.


See the [API Reference](./api-reference#olaptable) for complete configuration options and methods.

