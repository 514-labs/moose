use handlebars::Handlebars;

use crate::project::python_project::PythonProject;

#[derive(Debug, thiserror::Error)]
#[error("Failed to generate Typescript code")]
#[non_exhaustive]
pub enum PythonRenderingError {
    HandlebarError(#[from] handlebars::RenderError),
}

pub static PYTHON_BASE_MODEL_TEMPLATE: &str = r#"
# This file was auto-generated by the framework. You can add data models or change the existing ones

from moose_lib import Key, moose_data_model
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

# This decorator is used to mark the data model as a Moose data model
@moose_data_model
@dataclass
class Foo:
    primary_key: Key[str]
    timestamp: float
    optional_text: Optional[str]

@moose_data_model
@dataclass
class Bar:
    primary_key: Key[str]
    utc_timestamp: datetime
    has_text: bool
    text_length: int
"#;

pub static SETUP_PY_TEMPLATE: &str = r#"
from setuptools import setup

setup(
    name='{{name}}',
    version='{{version}}',
    install_requires=[
        {{#each dependencies}}
        "{{{ this }}}",
        {{/each}}
    ],
)
"#;

pub static PYTHON_BASE_STREAMING_FUNCTION_SAMPLE: &str = r#"
## Example Streaming Function: Transforms Foo data to Bar data

from moose_lib import StreamingFunction
from app.datamodels.models import Foo, Bar # Import your Moose data models to use in the streaming function
from datetime import datetime

# The 'run' function contains the logic that runs on each new data point in the Foo stream.
# For more details on how Moose streaming functions work, see: https://docs.moosejs.com
def run(foo: Foo) -> Bar:
    return Bar(
        primary_key=foo.primary_key,
        utc_timestamp=datetime.fromtimestamp(foo.timestamp),
        has_text=foo.optional_text is not None,
        text_length=len(foo.optional_text) if foo.optional_text else 0
    )

Foo__Bar = StreamingFunction(run=run) # Register the run function as a streaming function.
"#;

pub static PYTHON_BASE_STREAMING_FUNCTION_TEMPLATE: &str = r#"
# Import your Moose data models to use in the streaming function
{{source_import}}
{{destination_import}}
from moose_lib import StreamingFunction
from typing import Optional
from datetime import datetime

def fn(source: {{source}}) -> Optional[{{destination}}]:
    return {{destination_object}}

my_function = StreamingFunction(
    run=fn
)
"#;

pub static PYTHON_BASE_CONSUMPTION_TEMPLATE: &str = r#"
# This file is where you can define your API templates for consuming your data
#Query params are passed in as Pydantic models and are used within the sql tag to parameterize you queries

from moose_lib import MooseClient
from pydantic import BaseModel

class QueryParams(BaseModel):
    limit: Optional[int] = 10

def run(client: MooseClient, params: QueryParams):
    return client.query.execute("SELECT 1", {})
"#;

pub static PYTHON_BASE_API_SAMPLE: &str = r#"

# This file is where you can define your API templates for consuming your data

from moose_lib import MooseClient
from pydantic import BaseModel, Field
from typing import Optional

# Query params are defined as Pydantic models and are validated automatically
class QueryParams(BaseModel):
    order_by: Optional[str] = Field(
        default="total_rows",
        pattern=r"^(total_rows|rows_with_text|max_text_length|total_text_length)$",
        description="Must be one of: total_rows, rows_with_text, max_text_length, total_text_length"
    )
    limit: Optional[int] = Field(
        default=5,
        gt=0,
        le=100,
        description="Must be between 1 and 100"
    )
    start_day: Optional[int] = Field(
        default=1,
        gt=0,
        le=31,
        description="Must be between 1 and 31"
    )
    end_day: Optional[int] = Field(
        default=31,
        gt=0,
        le=31,
        description="Must be between 1 and 31"
    )
    
## The run function is where you can define your API logic
def run(client: MooseClient, params: QueryParams):
    
    start_day = params.start_day
    end_day = params.end_day
    limit = params.limit
    order_by = params.order_by
    
    query = f"""
    SELECT 
        day_of_month,
        {order_by}
    FROM BarAggregated_MV 
    WHERE day_of_month >= {start_day} 
    AND day_of_month <= {end_day} 
    ORDER BY {order_by} DESC
    LIMIT {limit}
    """    
   
    return client.query.execute(query, {"order_by": order_by, "start_day": start_day, "end_day": end_day, "limit": limit})

"#;

pub static PYTHON_BASE_BLOCKS_TEMPLATE: &str = r#"
# This file is where you can define your SQL queries to shape and manipulate batches
# of data using Blocks. Blocks can also manage materialized views to store the results of 
# your queries for improved performance. A materialized view is the recommended approach for aggregating
# data. For more information on the types of aggregate functions you can run on your existing data, 
# consult the Clickhouse documentation: https://clickhouse.com/docs/en/sql-reference/aggregate-functions

from moose_lib import (
    AggregationCreateOptions,
    AggregationDropOptions,
    Blocks,
    ClickHouseEngines,
    TableCreateOptions,
    create_aggregation,
    drop_aggregation,
)

teardown_queries = []

setup_queries = []

block = Blocks(teardown=teardown_queries, setup=setup_queries)
"#;

pub static PYTHON_BASE_BLOCKS_SAMPLE: &str = r#"
# This block is used to aggregate the data from the Bar table into a materialized view
from moose_lib import (
  Blocks
)

MV_NAME = "BarAggregated_MV" # The name of the materialized view

# The query to create the materialized view, which is executed when the block is set up
MV_QUERY = """
CREATE MATERIALIZED VIEW BarAggregated_MV
ENGINE = MergeTree()
ORDER BY day_of_month
POPULATE
AS
SELECT
  toDayOfMonth(utc_timestamp) as day_of_month,
  count(primary_key) as total_rows,
  countIf(has_text) as rows_with_text,
  sum(text_length) as total_text_length,
  max(text_length) as max_text_length
FROM Bar_0_0
GROUP BY toDayOfMonth(utc_timestamp)
"""

# The query to drop the materialized view, which is executed when the block is torn down
DROP_MV_QUERY = f"DROP TABLE IF EXISTS {MV_NAME}"

# The block to create the materialized view
block = Blocks(teardown=[DROP_MV_QUERY], setup=[MV_QUERY])
"#;

pub static PYTHON_BASE_SCRIPT_TEMPLATE: &str = r#"from moose_lib import task

@task()
def {{name}}(input: dict):  # The name of your script
    """
    Description of what this script does
    """
    # The body of your script goes here

    # The return value is the output of the script.
    # The return value should be a dictionary with at least:
    # - task: the task name (e.g., "extract", "transform")
    # - data: the actual data being passed to the next task
    return {
        "task": "{{name}}",  # The task name is the name of the script
        "data": None     # The data being passed to the next task (4MB limit)
    }
"#;

pub fn render_setup_py(project: PythonProject) -> Result<String, PythonRenderingError> {
    let reg = Handlebars::new();

    let template_context = serde_json::json!({
        "name": project.name,
        "version": project.version,
        "dependencies": project.dependencies,
    });

    Ok(reg.render_template(SETUP_PY_TEMPLATE, &template_context)?)
}
