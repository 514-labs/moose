{"version":3,"file":"transforms.js","sourceRoot":"","sources":["../../app/ingest/transforms.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mCAA8D;AAC9D,gDAAiE;AACjE,qCAAqC;AACrC,oBAAW,CAAC,MAAO,CAAC,YAAY,CAAC,oBAAW,CAAC,MAAO,EAAE,UAAO,GAAQ;;;;;oBAenD,qBAAM,sBAAU,CAAC,GAAG,EAAE,EAAA;;gBAA9B,KAAK,GAAG,SAAsB;gBAC9B,QAAQ,GAAG,oBAAa,GAAG,CAAC,UAAU,CAAE,CAAC;gBAEhC,qBAAM,KAAK,CAAC,GAAG,CAAM,QAAQ,CAAC,EAAA;;gBAAvC,MAAM,GAAG,SAA8B;gBAC7C,IAAI,MAAM,EAAE,CAAC;oBACT,OAAO,CAAC,GAAG,CAAC,kCAA2B,GAAG,CAAC,UAAU,CAAE,CAAC,CAAC;oBACzD,sBAAO,MAAM,EAAC;gBAClB,CAAC;gBACD,IAAI,GAAG,CAAC,SAAS,KAAK,YAAY,EAAE,CAAC;oBACjC,4CAA4C;oBAC5C,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC;gBAC5B,CAAC;gBACK,MAAM,GAAQ;oBAChB,UAAU,EAAE,GAAG,CAAC,UAAU;oBAC1B,YAAY,EAAE,IAAI,IAAI,CAAC,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC,EAAE,4BAA4B;oBAC1E,OAAO,EAAE,GAAG,CAAC,YAAY,KAAK,SAAS;oBACvC,UAAU,EAAE,MAAA,MAAA,GAAG,CAAC,YAAY,0CAAE,MAAM,mCAAI,CAAC;iBAC5C,CAAC;gBACF,sCAAsC;gBACtC,qBAAM,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,EAAA;;gBADvC,sCAAsC;gBACtC,SAAuC,CAAC;gBACxC,sBAAO,MAAM,EAAC;;;KACjB,EAAE;IACC,eAAe,EAAE,oBAAW,CAAC,eAAe;CAC/C,CAAC,CAAC;AACH,+CAA+C;AAC/C,IAAM,aAAa,GAAG,UAAC,GAAQ;;IAC3B,OAAO,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC;IACnC,OAAO,CAAC,GAAG,CAAC,yBAAkB,GAAG,CAAC,UAAU,CAAE,CAAC,CAAC;IAChD,OAAO,CAAC,GAAG,CAAC,uBAAgB,IAAI,IAAI,CAAC,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC,CAAE,CAAC,CAAC;IAC9D,OAAO,CAAC,GAAG,CAAC,2BAAoB,MAAA,GAAG,CAAC,YAAY,mCAAI,MAAM,CAAE,CAAC,CAAC;IAC9D,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACvB,CAAC,CAAC;AACF,oBAAW,CAAC,MAAO,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;AAC/C,2DAA2D;AAC3D,oBAAW,CAAC,eAAgB,CAAC,WAAW,CAAC,UAAC,UAAU;IAChD,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IACxB,IAAM,GAAG,GAAQ,UAAU,CAAC,OAAO,EAAE,CAAC;IACtC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACrB,CAAC,CAAC,CAAC","sourcesContent":["import { FooPipeline, BarPipeline, Foo, Bar } from \"./models\";\nimport { DeadLetterQueue, MooseCache } from \"@514labs/moose-lib\";\n// Transform Foo events to Bar events\nFooPipeline.stream!.addTransform(BarPipeline.stream!, async (foo: Foo): Promise<Bar> => {\n    /**\n     * Transform Foo events to Bar events with error handling and caching.\n     *\n     * Normal flow:\n     * 1. Check cache for previously processed events\n     * 2. Transform Foo to Bar\n     * 3. Cache the result\n     * 4. Return transformed Bar event\n     *\n     * Alternate flow (DLQ):\n     * - If errors occur during transformation, the event is sent to DLQ\n     * - This enables separate error handling, monitoring, and retry strategies\n    */\n    // Initialize cache\n    const cache = await MooseCache.get();\n    const cacheKey = `processed:${foo.primaryKey}`;\n    // Check if we have processed this event before\n    const cached = await cache.get<Bar>(cacheKey);\n    if (cached) {\n        console.log(`Using cached result for ${foo.primaryKey}`);\n        return cached;\n    }\n    if (foo.timestamp === 1728000000.0) {\n        // magic value to test the dead letter queue\n        throw new Error(\"blah\");\n    }\n    const result: Bar = {\n        primaryKey: foo.primaryKey,\n        utcTimestamp: new Date(foo.timestamp * 1000), // Convert timestamp to Date\n        hasText: foo.optionalText !== undefined,\n        textLength: foo.optionalText?.length ?? 0,\n    };\n    // Cache the result (1 hour retention)\n    await cache.set(cacheKey, result, 3600);\n    return result;\n}, {\n    deadLetterQueue: FooPipeline.deadLetterQueue,\n});\n// Add a streaming consumer to print Foo events\nconst printFooEvent = (foo: Foo): void => {\n    console.log(\"Received Foo event:\");\n    console.log(`  Primary Key: ${foo.primaryKey}`);\n    console.log(`  Timestamp: ${new Date(foo.timestamp * 1000)}`);\n    console.log(`  Optional Text: ${foo.optionalText ?? \"None\"}`);\n    console.log(\"---\");\n};\nFooPipeline.stream!.addConsumer(printFooEvent);\n// DLQ consumer for handling failed events (alternate flow)\nFooPipeline.deadLetterQueue!.addConsumer((deadLetter) => {\n    console.log(deadLetter);\n    const foo: Foo = deadLetter.asTyped();\n    console.log(foo);\n});\n"]}