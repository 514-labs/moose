import { Callout, BulletPointsCard, CheckmarkBullets, LanguageSwitcher, TypeScript, Python } from "@/components";
import { Tabs } from "nextra/components";

# Database Tables
<LanguageSwitcher />
Tables are the foundation of Moose's data storage layer, designed to integrate with your entire data pipeline. They store data ingested from your APIs and streams while powering your analytics queries for your downstream transformations, APIs, and more.

## Overview

Tables in Moose provide a type-safe way to define your database schema directly in your code, eliminating the tedious database administration tasks that typically interrupt your development flow.

<BulletPointsCard
title="Working with OLAP Tables"
bullets={[
  {
    title: "Define your table schema as a data model",
    description: "Create a type definition that describes your table structure"
  },
  {
    title: "Instantiate your table",
    description: "Create a typed table instance from your model with one line of code"
  },
  {
    title: "Configure storage options",
    description: "Optionally specify indexing, ordering, and other optimizations for your query patterns"
  },
  {
    title: "Iterate on your schema",
    description: "Add, edit, or remove fields and tables update automatically"
  }
]}
/>

### Basic Example

<TypeScript>
```ts filename="FirstTable.ts" copy
interface MyFirstTable {
  id: Key<string>;
  name: string;
  age: number;
}

const myTable = new OlapTable<MyFirstTable>("my_first_table");
```
</TypeScript>

<Python>
```py filename="FirstTable.py" copy
from pydantic import BaseModel
from moose_lib import Key, OlapTable
from pydantic import BaseModel

class MyFirstTable(BaseModel):
    id: Key[str]
    name: str
    age: int

my_table = OlapTable[MyFirstTable]("my_first_table")
```
</Python>


<CheckmarkBullets
  title="Benefits:"
  bullets={[
    "Boilerplate CREATE/ALTER TABLE statements handled for you",
    "Automatic type mapping between your code and database types",
    "Built-in validation before storage"
  ]}
/>

## Creating Tables
There are two main approaches to creating tables:
- [Standalone Tables](#standalone-tables)
- [Tables in Ingestion Pipelines](#tables-in-ingestion-pipelines)

<Tabs items={["IngestPipelines (Recommended)", "Standalone Tables"]}>
<Tabs.Tab title="IngestPipelines (Recommended)">
### Creating Tables in Ingestion Pipelines

For end-to-end data flows, create tables as part of an ingestion pipeline:

<TypeScript>
```ts filename="PipelineTable.ts"
import { IngestPipeline, Key } from "@514labs/moose-lib";

// Define your schema
interface UserEvent {
  id: Key<string>;
  userId: string;
  timestamp: Date;
  eventType: string;
  properties: object;
}

// Create a complete ingestion pipeline with a table
const eventsPipeline = new IngestPipeline<UserEvent>("user_events_pipeline", {
  ingest: true,    // Creates a REST API endpoint 
  stream: true,    // Creates Kafka/Redpanda topic
  table: {         // Creates and configures the table
    orderByFields: ["id", "timestamp"],
    deduplicate: true
  }
});

// Access the table component when needed
const eventsTable = eventsPipeline.table;
```
</TypeScript>

<Python>
```py filename="PipelineTable.py"
from moose_lib import IngestPipeline, Key, OlapTable
from pydantic import BaseModel

class UserEvent(BaseModel):
    id: Key[str]
    user_id: str
    timestamp: Date
    event_type: str
    properties: dict

events_pipeline = IngestPipeline[UserEvent]("user_events_pipeline", {
  ingest: True,
  stream: True,
  table: {
    orderByFields: ["id", "timestamp"],
    deduplicate: True
  }
})

# Access the table component when needed:
events_table = events_pipeline.table
```
</Python>

This integrated approach automatically creates the necessary infrastructure and connects all components, ensuring data flows smoothly from API to database with full type checking at every step.

</Tabs.Tab>

<Tabs.Tab title="Standalone Tables">

Create a table directly for custom data flows or when you need fine-grained control:

<TypeScript>
```ts filename="StandaloneTable.ts"
import { OlapTable, Key } from "@514labs/moose-lib";

// Define your schema
interface ExampleSchema {
  id: Key<string>;
  dateField: Date;
  numericField: number;
  booleanField: boolean;
  floatField: number;
  integerField: number & tags.Type<"int64">; // Moose supports native tagged types so you can use Integers in typescript
}

// Create a standalone table
const exampleTable = new OlapTable<ExampleSchema>("example_table", {
  orderByFields: ["id", "dateField"], // Optional when using a primary key
  deduplicate: true  // Optional: keep only the latest version of each record
});

// Now you can:
// - Write to this table from streams
// - Query it directly
// - Use it as a source for materialized views
```
</TypeScript>

<Python>
```py filename="StandaloneTable.py"
from moose_lib import Key, OlapTable
from pydantic import BaseModel

class ExampleSchema(BaseModel):
    id: Key[str]
    date_field: Date
    numeric_field: float
    boolean_field: bool

example_table = OlapTable[ExampleSchema]("example_table", {
  orderByFields: ["id", "date_field"],
  deduplicate: True
})
```
</Python>

Standalone tables are useful for:
- When you need to do a bulk import of data
- When you have in-memory ETL/ELT workflows that need to write directly to a table as opposed to a streaming ingestion pipeline
- When you have some external service that is maintaining and writing to the table, like a CDC or other external ETL service

</Tabs.Tab>
</Tabs>

## Querying Tables

Moose provides a `sql` tagged template literal function that you can use to write SQL queries on your tables, which supports interpolation of table names, column names, and values.

This is useful for:
- Transforming your data in your database and saving the results as regular views or [materialized views](/moose/materialized-views).
- Querying tables from your [Consumption API route handlers](/moose/consumption-api) to expose your data to client applications that are running outside of Moose.



```ts filename="QueryingTables.ts"
import { sql } from "@514labs/moose-lib";

interface MyTableSchema {
  id: Key<string>;
  name: string;
  value: number;
}

const myTable = new OlapTable<MyTableSchema>("my_table");

const query = sql`
  SELECT ${myTable.id}, ${myTable.name}, ${myTable.value} FROM ${myTable}
`;

// When Moose runs this query, it will automatically convert the interpolated values into the correct SQL syntax for your database:
// SELECT id, name, value FROM my_table
```

This lets you write SQL that feels like TypeScript - get autocomplete for your table columns and catch typos at dev time instead of waiting for runtime.

## Configuring Table Indexes

You must configure table indexing using one of these approaches:
1. Define at least one `Key` in your table schema
2. Specify `orderByFields` in the table config
3. Use both (all `Key` fields must come first in the `orderByFields` array)

```ts filename="PrimaryKeyConfig.ts"
import { OlapTable, Key } from '@514labs/moose-zlib';

// Approach 1: Using primary key only
interface Record1 {
  id: Key<string>;  // Primary key field
  field1: string;
  field2: number;
}

const table1 = new OlapTable<Record1>("table1");  // Uses id as orderByField automatically
```

### Order By Fields Only

```ts filename="OrderByFieldsOnly.ts"
// Approach 2: Using orderByFields only
interface SchemaWithoutPrimaryKey {
  field1: string;
  field2: number;
  field3: Date;
}

const tableWithOrderByFieldsOnly = new OlapTable<SchemaWithoutPrimaryKey>("table2", {
  orderByFields: ["field1", "field2"]  // Specify ordering without primary key
});
```

### Using Both Primary Key and Order By Fields
```ts filename="ComboKeyAndOrderByFields.ts"
// Approach 3: Using both (primary key must be first)
interface SchemaWithKey {
  id: Key<string>;  // Primary key field
  field1: string;
  field2: number;
}

const tableWithKeyAndOrderByFields = new OlapTable<SchemaWithKey>("table3", {
  orderByFields: ["id", "field1"]  // Primary key must be first
});
```

### Using Multiple Primary Keys
```ts filename="MultiKeyTable.ts"
interface MultiKeyRecord {
  key1: Key<string>;
  key2: Key<number>;
  field1: string;
}

const multiKeyTable = new OlapTable<MultiKeyRecord>("multi_key_table", {
  orderByFields: ["key1", "key2", "field1"]  // Multiple keys must come first
});
```

### Deduplication
Keep only the latest record per key:
```ts filename="DeduplicatedTable.ts"
const table = new OlapTable<Record>("table", {
  orderByFields: ["id"],
  deduplicate: true
});
```

<Callout type="warning" title="Deduplication Caveats">
Deduplication uses ClickHouse's ReplacingMergeTree engine for eventual deduplication, meaning duplicate records may not be removed immediately. This process can take time and is not guaranteed to be immediate. For more details, see the [ClickHouse documentation](https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/replacingmergetree).
</Callout>


### Invalid Configurations
```ts filename="InvalidConfig.ts"
// Error: No primary key or orderByFields
interface BadRecord1 {
  field1: string;
  field2: number;
}
const badTable1 = new OlapTable<BadRecord1>("bad_table1");

// Error: Primary key not first in orderByFields
interface BadRecord2 {
  id: Key<string>;
  field1: string;
}
const badTable2 = new OlapTable<BadRecord2>("bad_table2", {
  orderByFields: ["field1", "id"]  // Wrong order - primary key must be first
});

// Error: Nullable field in orderByFields
interface BadRecord3 {
  id: Key<string>;
  field1: string;
  field2?: number;
}
const badTable3 = new OlapTable<BadRecord3>("bad_table3", {
  orderByFields: ["id", "field2"]  // Can't have nullable field in orderByFields
});
```

### Best Practices
1. **Schema Design**
   - Use non-nullable fields for sorting/indexing
   - Make fields optional only when necessary
   - Consider query patterns when choosing `orderByFields`

2. **Performance**
   - Order fields based on common query patterns
   - Use deduplication for latest-version scenarios
   - Consider data volume for partitioning


## How It Works

<BulletPointsCard
  title="How it works:"
  bullets={[
    {
      title: "Define your data model",
      description: "Create a type definition that describes your table structure"
    },
    {
      title: "Instantiate your table",
      description: "Create a typed table instance from your model with one line of code"
    },
    {
      title: "Configure storage options",
      description: "Optionally specify ordering, partitioning, and other optimizations"
    },
    {
      title: "Evolve your schema",
      description: "Add fields to your model and tables update automatically"
    }
  ]}
/>

// Code example goes here

<CheckmarkBullets
  title="Benefits:"
  bullets={[
    "No SQL boilerplate or CREATE/ALTER TABLE statements",
    "Type-safe schema evolution with automatic migration",
    "Automatic index creation based on key definitions",
    "Database types derived directly from your application types",
    "Built-in validation before storage"
  ]}
/>

## Development Workflow

### Local Development with Hot Reloading

One of the powerful features of Moose is its integration with the local development server:

1. Start your local development server with `moose dev`
2. When you define or modify an `OlapTable` in your code and save the file:
   - The changes are automatically detected
   - The TypeScript compiler plugin processes your schema definitions
   - The infrastructure is updated in real-time to match your code changes
   - Your tables are immediately available for testing

For example, if you add a new field to your schema:
```typescript
// Before
interface BasicSchema {
  id: Key<string>;
  name: string;
}

// After adding a field
interface BasicSchema {
  id: Key<string>;
  name: string;
  createdAt: Date;  // New field
}
```

The Moose framework will:
1. Detect the change when you save the file
2. Update the table schema in the local ClickHouse instance
3. Make the new field immediately available for use

### Verifying Your Tables

You can verify your tables were created correctly using:
```bash
# List all tables in your local environment
moose ls
```

Or by connecting directly to your local ClickHouse instance and running SQL commands.


See the [API Reference](./api-reference#olaptable) for complete configuration options and methods.

