---
authors: George Leung <george@fiveonefour.com>
title: Safe Database Schema Migration and Change Management
state: discussion
---

## Abstract

This RFD proposes a comprehensive approach to database schema migration and change management for Moose deployments
that prioritizes safety, user control, and minimal operational overhead.
The current solution lacks essential safeguards against unintended data loss and
provides insufficient user control over schema evolution.

The proposed solution implements a **Migration Plan Review and Approval** workflow where the system generates
migration plans before deployment, allows user review and editing, and requires explicit approval before
execution. This approach provides explicit user consent for destructive operations while maintaining
flexibility for automated deployments in development environments.

## Motivation / Problem Description

The current schema migration system in Moose has several critical limitations that impact production deployments.

### Current Process Issues

In production mode, we load the infrastructure map stored in the docker image,
update it according to the real database state,
diff the changes, and apply them automatically.

1. **Unintended Data Loss**: `DROP COLUMN` operations happen automatically without user awareness or approval.

2. **No User Control**:
   When users intend to rename a column,
   the system interprets this as a `DROP COLUMN` followed by `ADD COLUMN`.
   Data loss aside, the user has no way to specify how the schema is migrated.

3. **State Inconsistency**:
   The `integrate-changes` command modifies the infrastructure map,
   but redeploying the same version means the stored infrastructure map in the image doesn't contain the new changes,
   causing the system to drop tables as they're not in the desired state.

4. **Async Cast Failures**:
   `ALTER TABLE MODIFY COLUMN` operations don't change underlying data, and cast operations can fail asynchronously.

### Goals

- **Easy Migration**: Minimize work required for most common schema change scenarios
- **User Control**: Provide full control and customization capabilities when needed  
- **Safe Deployment**: Protect against unintended data loss during deployments and rollbacks
- **Explicit Data Deletion**: Only drop data when the user explicitly requests it
- **Rollback Safety**: Handle rollback scenarios without automatic data loss

### Non-Goals

- **Changing non-Moose managed database objects**: External tables, views, or procedures created outside of Moose

## Solution: Migration Plan Review and Approval

### Overview

The plan is created and approved before deployment,
and is not committed to the code base nor included in the container image.

1. **Planning**: System generates migration plan before deployment
2. **Review**:
   - Runs image with `moose-cli plan` entry point, OR
   - Send the target infrastructure map to running instance for plan generation
3. **Approval**: User reviews, edits, and approves the plan
4. **Execution**: Approved plan gets injected into deployed container

**Auto Approval Workflow**:
- Runtime environment variable enables automatic plan approval and execution
- Suitable for development and staging environments

#### Benefits
- Minimal time between plan generation and deployment.

#### Downsides
- No more push-to-main-and-deploy workflow
unless the user turns on auto-approval - which is the same as the current solution.


## Alternative Approaches Considered

### SQL Generation Workflow

#### Overview
Generate SQL migration scripts as part of the development process rather than executing changes directly at runtime.

#### Process
1. **Pre-deployment Diff**: Compare against a reference version
  (remote Moose state, or the end state of accumulated migration scripts.)
2. **SQL Script Generation**: Produce SQL statements similar to our current solution but output to files instead of executing
3. **User Review**: Require user to commit SQL files containing `DROP COLUMN` statements - no surprise data loss

#### Benefits
- Explicit user consent for destructive operations
- Version control for schema changes
- Predictable migration behavior

#### Challenges
- **Version Coordination**: If version 1 diffs against version 0, and version 2 also diffs against version 0,
  then version 1 is deployed, version 2's SQL statements become invalid
- **External Changes**: Need mechanisms to cope with external database modifications
- **Rollback Complexity**: Rollbacks require new images with new SQL statements,
  adding build time when rapid fixes are needed

### Git History Integration

#### Overview
Embed git history into Docker images to maintain change lineage and enable safe redeployments.

#### Process
1. **Change Tracking**: Include git commit history in container images
2. **State Consistency**: Use git history to determine what changes have been applied
3. **Safe Redeployment**: Prevent dropping changes that were applied in previous versions

#### Benefits
- Solves redeployment safety issues
- Maintains change history
- Enables rollback tracking

#### Challenges
- Container size increase
- Complexity in change tracking logic
- Integration with existing CI/CD pipelines

### User Override System

#### Overview
Maintain the current solution but add user-provided transformation layer for change operations.

#### Process
1. **Change Detection**: Generate a sequence of actions as in the existing behaviour
2. **User Transform Function**: Pass the actions through user-provided `OlapChange[] => OlapChange[]` transformation
3. **Full Flexibility**: Users can modify, reorder, or completely replace the generated changes

#### Benefits
- Maximum flexibility and user control
- Backward compatibility with the current system
- Handles edge cases through user customization

#### Challenges
- Requires user to anticipate changes done by moose
- Potential for user errors in transformation logic

## Open Questions

1. **Update Atomicity**: How do we handle/stop concurrent writes when a migration is in progress?

2. **Performance at Scale**: How do migrations perform on large tables?
  Changing subfields in Nested/Tuple requires an `ALTER TABLE UPDATE` mutation.

3. **Plan Data structure**:
   How should a plan be represented?
   It can be a custom data type, e.g. `{"type": "DropColumn", "column_name": "stuff"}` (or in YAML).
   This is a high level representation but developers have to learn the schema.
   The plan can also be in SQL statements, but it is harder for Moose to validate.
