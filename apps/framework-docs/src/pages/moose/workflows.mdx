---
title: Moose Workflows
description: Build ETL pipelines, scheduled jobs, and long-running tasks with orchestration
---

import { Callout, LanguageSwitcher, BulletPointsCard, TypeScript, Python, CTACards, CTACard, ExportRequirement } from "@/components";
import { FileTree } from "nextra/components";

# Moose Workflows
<LanguageSwitcher />

## Overview

The Workflows module provides standalone task orchestration and automation. You can use this capability independently to build ETL pipelines, run scheduled jobs, trigger background tasks, and manage long-running tasks without requiring other MooseStack components like databases or streams.

### Basic Usage

<ExportRequirement primitive="Workflow and Task" example="export { myworkflow, task1, task2 }" />

<TypeScript>
```typescript filename="DataFlow.ts" copy
import { Task, Workflow } from "@514labs/moose-lib";

export interface Foo {
  name: string;
}

export interface Bar {
  name: string;
  greeting: string;
  counter: number;
}

export const task1 = new Task<Foo, Bar>("task1", {
  run: async (ctx) => {
    const greeting = `hello, ${ctx.input.name}!`;
    return {
      name: ctx.input.name,
      greeting,
      counter: 1
    };
  },
});

export const task2 = new Task<Bar, void>("task2", {
  run: async (ctx) => {
    console.log(`${ctx.input.greeting} (count: ${ctx.input.counter})`);
  },
});

export const myworkflow = new Workflow("myworkflow", {
  startingTask: task1
});

```
</TypeScript>

<Python>
```python filename="DataFlow.py" copy
from moose_lib import Task, TaskConfig, TaskContext, Workflow, WorkflowConfig
from pydantic import BaseModel

class Foo(BaseModel):
    name: str

class Bar(BaseModel):
    name: str
    greeting: str
    counter: int

def run_task1(ctx: TaskContext[Foo]) -> Bar:
    greeting = f"hello, {ctx.input.name}!"
    return Bar(
        name=ctx.input.name,
        greeting=greeting,
        counter=1
    )

def run_task2(ctx: TaskContext[Bar]) -> None:
    print(f"{ctx.input.greeting} (count: {ctx.input.counter})")

task1 = Task[Foo, Bar](
    name="task1",
    config=TaskConfig(run=run_task1, on_complete=[task2])
)

task2 = Task[Bar, None](
    name="task2",
    config=TaskConfig(run=run_task2)
)

myworkflow = Workflow(
    name="myworkflow",
    config=WorkflowConfig(starting_task=task1)
)

# No export needed - Python modules are automatically discovered
```
</Python>

### Enabling Workflows

To enable workflows, you need to add the `workflows` feature to your `moose.config.toml` file:

```toml filename="moose.config.toml" copy
[features]
workflows = true
```
## Core Capabilities

<CTACards>
<CTACard
  title="Define Workflows"
  description="Create workflow definitions with task sequences and data flow"
  ctaLink="/moose/workflows/define-workflow"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "Definition" }}
/>
<CTACard
  title="Schedule Workflows"
  description="Set up recurring and scheduled workflow execution"
  ctaLink="/moose/workflows/schedule-workflow"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "Scheduling" }}
/>
<CTACard
  title="Trigger Workflows"
  description="Start workflows from events, APIs, or external triggers"
  ctaLink="/moose/workflows/trigger-workflow"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "Triggers" }}
/>
</CTACards>

## Integration with Other Capabilities

While the Workflows capability works independently, it is designed to be used in conjunction with other MooseStack capabilities:

<CTACards columns={1}>
<CTACard
  title="OLAP"
  description="For batch data ingest, use workflows to run batch data extraction, transformations, and then load directly into your OLAP tables with the `OlapTable.insert()` method."
  ctaLink="/moose/olap/insert-data"
  ctaLabel="Learn More →"
  orientation="horizontal"
  isMooseModule={true}
/>
<CTACard
  title="APIs"
  description="Trigger workflows from API endpoints or call APIs from workflow tasks."
  ctaLink="/moose/apis/trigger-api"
  ctaLabel="Learn More →"
  orientation="horizontal"
  isMooseModule={true}
/>
</CTACards>

