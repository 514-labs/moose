{"version":3,"file":"1.fetchEvents.js","sourceRoot":"","sources":["../../app/scripts/getGithubEvents/1.fetchEvents.ts"],"names":[],"mappings":"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","sourcesContent":["import { TaskFunction, TaskDefinition, cliLog } from \"@514labs/moose-lib\";\nimport {\n  EventType,\n  EventResponseType,\n  EventRequestOptions,\n  FetchEventsOutput,\n  createOctokit,\n  loadEtag,\n  saveEtag,\n} from \"../utils\";\n\nconst fetchEvents: TaskFunction = async (input?: any) => {\n  console.log(\"Fetching latest GitHub public events\");\n\n  const octokit = createOctokit();\n\n  let allEvents: EventType = [];\n  const maxPages = 3; // Limit to 3 pages (300 events) to avoid rate limits\n  let noNewEvents = false;\n  const etag = loadEtag();\n\n  try {\n    // Fetch events with pagination\n    for (let page = 1; page <= maxPages; page++) {\n      try {\n        const requestOptions: EventRequestOptions = {\n          per_page: 100, // Maximum allowed per page\n          page: page,\n        };\n\n        if (page == 1 && etag) {\n          requestOptions.headers = {\n            \"If-None-Match\": etag,\n          };\n        }\n\n        const response: EventResponseType =\n          await octokit.rest.activity.listPublicEvents(requestOptions);\n\n        // Save the new etag for future requests\n        const newEtag = response.headers.etag as string;\n        if (newEtag && newEtag !== etag) {\n          saveEtag(newEtag);\n        }\n\n        // Add current page events to our collection\n        if (page === 1) {\n          allEvents = response.data;\n        } else {\n          allEvents = [...allEvents, ...response.data];\n        }\n\n        // Check for Link header to handle pagination\n        const hasNextPage =\n          response.headers.link?.includes('rel=\"next\"') || false;\n        if (!hasNextPage) {\n          break; // Exit the loop if no more pages\n        }\n      } catch (error: any) {\n        // Handle 304 Not Modified (only possible on the first page)\n        if (page === 1 && error.status === 304) {\n          console.log(\n            \"304 Not Modified - No new events available since last fetch\",\n          );\n          noNewEvents = true;\n          break; // Exit the loop, no need to fetch more pages\n        } else {\n          throw error; // Re-throw other errors\n        }\n      }\n    }\n\n    const pagesProcessed =\n      allEvents.length > 0 ? Math.ceil(allEvents.length / 100) : 0;\n    console.log(\n      `${noNewEvents ? \"No new events\" : `Successfully fetched ${allEvents.length} events from ${pagesProcessed} pages`}`,\n    );\n\n    return {\n      task: \"fetchEvents\",\n      data: {\n        events: noNewEvents ? [] : allEvents,\n        fetchedAt: new Date().toISOString(),\n        count: allEvents.length,\n        noNewEvents,\n      },\n    } as { task: string; data: FetchEventsOutput };\n  } catch (error) {\n    console.error(\"Error fetching GitHub events:\", error);\n    throw error; // Let the task framework handle retries\n  }\n};\n\nexport default function createTask() {\n  return {\n    task: fetchEvents,\n    config: {\n      retries: 3,\n    },\n  } as TaskDefinition;\n}\n"]}