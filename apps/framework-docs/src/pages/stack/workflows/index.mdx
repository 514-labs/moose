---
title: Moose Workflows
description: Build ETL pipelines, scheduled jobs, and long-running tasks with orchestration
---

import { Callout, LanguageSwitcher, BulletPointsCard, TypeScript, Python, CTACards, CTACard } from "@/components";
import { FileTree } from "nextra/components";

# Workflows
<LanguageSwitcher />

## Overview

The Workflows capability provides standalone task orchestration and automation. You can use this capability independently to build ETL pipelines, scheduled jobs, and long-running tasks without requiring other MooseStack components like databases or streams.

<BulletPointsCard
  title="Working with Workflows"
  bullets={[
    {
      title: "Define task sequences",
      description: "Create ordered sequences of tasks that execute reliably"
    },
    {
      title: "Type-safe data flow",
      description: "Pass data between tasks with full type safety and validation"
    },
    {
      title: "Reliable execution",
      description: "Built on Temporal for fault tolerance and retry capabilities"
    },
    {
      title: "Standalone orchestration",
      description: "Orchestrate any type of work without requiring databases or streams"
    }
  ]}
/>

## Core Capabilities

<CTACards>
<CTACard
  title="Define Workflows"
  description="Create workflow definitions with task sequences and data flow"
  ctaLink="/moosestack/workflows/define-workflow"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "Definition" }}
/>
<CTACard
  title="ETL Workflows"
  description="Build extract, transform, load pipelines for data processing"
  ctaLink="/moosestack/workflows/etl-workflow"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "ETL" }}
/>
<CTACard
  title="Schedule Workflows"
  description="Set up recurring and scheduled workflow execution"
  ctaLink="/moosestack/workflows/schedule-workflow"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "Scheduling" }}
/>
<CTACard
  title="Trigger Workflows"
  description="Start workflows from events, APIs, or external triggers"
  ctaLink="/moosestack/workflows/trigger-workflow"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "Triggers" }}
/>
<CTACard
  title="Long-Running Tasks"
  description="Handle tasks that require extended execution time"
  ctaLink="/moosestack/workflows/long-running-tasks"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "Long-running" }}
/>
</CTACards>

## Standalone Usage

The Workflows capability is designed to work independently. You can use it without requiring other MooseStack components:

<BulletPointsCard
  title="Independent Task Orchestration"
  bullets={[
    {
      title: "No database required",
      description: "Orchestrate tasks that work with external services or APIs"
    },
    {
      title: "Flexible task types",
      description: "Execute any type of work - API calls, file processing, data transformations"
    },
    {
      title: "Reliable execution",
      description: "Built on Temporal for fault tolerance, retries, and monitoring"
    },
    {
      title: "Scalable orchestration",
      description: "Scale workflow execution independently based on your workload"
    }
  ]}
/>

## Integration with Other Capabilities

While the Workflows capability works standalone, it seamlessly integrates with other MooseStack capabilities:

- **OLAP Database**: Use workflows to populate tables, run migrations, or perform data maintenance
- **APIs**: Trigger workflows from API endpoints or call APIs from workflow tasks
- **Streaming**: Process stream events with workflow tasks or trigger workflows from streams
- **Runtime**: Deploy and manage workflow infrastructure

## Writing Workflow Tasks

<TypeScript>
Tasks are defined as objects with a `run` asynchronous function that perform operations and return data for the next task:

```typescript filename="app/index.ts" copy
import { Task, Workflow } from "@514labs/moose-lib";

export interface Foo {
  name: string;
}

export const task1 = new Task<Foo, void>("task1", {
  run: async (input: Foo) => {
    const name = input.name ?? "world";
    const greeting = `hello, ${name}!`;
    console.log(greeting);
  },
});

export const myworkflow = new Workflow("myworkflow", {
  startingTask: task1,
});
```
</TypeScript>

<Python>
```python filename="app/main.py" copy
from moose_lib import Task, TaskConfig, Workflow, WorkflowConfig
from pydantic import BaseModel

class Foo(BaseModel):
  name: str;

def run_task1(input: Foo) -> None:
  name = input.name or "world"
  greeting = f"hello, {name}!"

task1 = Task[Foo, None](
  name="task1",
  config=TaskConfig(run=run_task1)
)

myworkflow = Workflow(
  name="myworkflow",
  config=WorkflowConfig(starting_task=task1)
)
```
</Python>

## Data Flow Between Tasks

Tasks communicate through their return values. Each task can return an object that is automatically passed as input to the next task in the workflow.

- Only values inside the object are passed to the next task
- The object must be JSON-serializable
- Full type safety is maintained throughout the workflow

<TypeScript>
```typescript filename="DataFlow.ts" copy
import { Task, Workflow } from "@514labs/moose-lib";

export interface Foo {
  name: string;
}

export interface Bar {
  name: string;
  greeting: string;
  counter: number;
}

export const task1 = new Task<Foo, Bar>("task1", {
  run: async (input: Foo) => {
    const greeting = `hello, ${input.name}!`;
    return {
      name: input.name,
      greeting,
      counter: 1
    };
  },
});

export const task2 = new Task<Bar, void>("task2", {
  run: async (input: Bar) => {
    console.log(`${input.greeting} (count: ${input.counter})`);
  },
});

export const myworkflow = new Workflow("myworkflow", {
  startingTask: task1,
  nextTask: task2,
});
```
</TypeScript>

<Python>
```python filename="DataFlow.py" copy
from moose_lib import Task, TaskConfig, Workflow, WorkflowConfig
from pydantic import BaseModel

class Foo(BaseModel):
    name: str

class Bar(BaseModel):
    name: str
    greeting: str
    counter: int

def run_task1(input: Foo) -> Bar:
    greeting = f"hello, {input.name}!"
    return Bar(
        name=input.name,
        greeting=greeting,
        counter=1
    )

def run_task2(input: Bar) -> None:
    print(f"{input.greeting} (count: {input.counter})")

task1 = Task[Foo, Bar](
    name="task1",
    config=TaskConfig(run=run_task1)
)

task2 = Task[Bar, None](
    name="task2",
    config=TaskConfig(run=run_task2)
)

myworkflow = Workflow(
    name="myworkflow",
    config=WorkflowConfig(starting_task=task1, next_task=task2)
)
```
</Python>

<Callout type="info" title="Powered by Temporal">
This workflow abstraction is powered by Temporal under the hood. You can use the Temporal GUI to monitor your workflow runs as they execute, providing extra debugging capabilities.
</Callout>

<Callout type="info">
**Getting Started**: Begin with [Define Workflows](/moosestack/workflows/define-workflow) to understand how to create your first workflow with task orchestration.
</Callout>
