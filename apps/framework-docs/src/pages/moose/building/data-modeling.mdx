import { Callout, LanguageSwitcher, TypeScript, Python, FeatureCard, FeatureGrid, CheckmarkBullets, BulletPointsCard } from "@/components";
import { FileTree, Tabs } from "nextra/components";

# Data Modeling
<LanguageSwitcher />
Data modeling is the core of Moose. You define your types once, then explicitly choose how to instantiate them across your infrastructure.

## Overview
Unlike traditional data engineering workflows where you are responsible for manually syncing schemas between components, Moose lets you programmatically decide which infrastructure elements to generate from your types.

<BulletPointsCard
  title="How it works:"
  bullets={[
    {
      title: "Define your schemas",
      description: "Create type definitions in TypeScript or Python"
    },
    {
      title: "Choose your components",
      description: "Decide which infrastructure pieces to create (APIs, streams, tables)"
    },
    {
      title: "Fine-tune behavior",
      description: "More granular control over how your infrastructure should behave if desired"
    }
  ]}
/>

### Quick Start
<TypeScript>
```ts filename="app/index.ts" copy
// 1. Define your schema (WHAT your data looks like)
interface MyDataModel {
  primaryKey: Key<string>;
  someString: string;
  someNumber: number;
  someDate: Date;
}

// 2. YOU control which infrastructure to create (HOW to handle your data)
const pipeline = new IngestPipeline<MyDataModel>("MyDataPipeline", {
  ingest: true,    // Optional: Create API endpoint
  stream: true,    // Optional: Create topic
  table: {         // Optional: Create and configure table
    orderByFields: ["primaryKey", "someDate"],
    deduplicate: true
  }
});
```
</TypeScript>
<Python>
```python filename="app/main.py"
# 1. Define your schema (WHAT your data looks like)
class MyFirstDataModel(BaseModel):
    id: Key[str] = Field(..., description="Primary key")
    some_string: str
    some_number: int
    some_boolean: bool
    some_date: datetime


# 2. YOU control which infrastructure to create (HOW to handle your data)
my_first_pipeline = IngestPipeline[MyFirstDataModel]("my_first_pipeline", IngestPipelineConfig(
    ingest=True,  // Create API endpoint
    stream=True,  // Create stream topic
    table=True    // Create database table
))
```
</Python>

<CheckmarkBullets
  title="Benefits:"
  bullets={[
    "End-to-end type safety across your code and infrastructure",
    "Full control over your infrastructure with code",
    "Zero schema drift - change your types in one place, automatically update your infrastructure"
  ]}
/>

## Schema Definition

<Callout type="info" title="The WHAT">
  This section covers how to define your data models - the structure and types of your data.
</Callout>

### Basic Types

<TypeScript>
```typescript filename="app/datamodels/BasicDataModel.ts"
import { Key } from "@514labs/moose-lib";

export interface BasicDataModel {
  // Required: Primary key for your data model
  primaryKey: Key<string>;    // string key
  // or
  numericKey: Key<number>;    // numeric key

  // Common types
  someString: string;         // Text
  someNumber: number;         // Numbers
  someBoolean: boolean;       // Boolean
  someDate: Date;             // Timestamps
  someArray: string[];        // Arrays
  someObject: object;         // Objects
  
  // Optional fields
  optionalField?: string;         // May not be present in all records
  nullableField?: string | null;  // May be present or not
}
```
</TypeScript>

<Python>
You use Pydantic to define your schemas:

```python filename="app/datamodels/BasicDataModel.py"
from moose_lib import Key
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel, Field

class BasicDataModel(BaseModel):
    # Required: Primary key for your data model
    primary_key: Key[str] = Field(..., description="String primary key")
    # or
    numeric_key: Key[int] = Field(..., description="Numeric primary key")
    
    # Common types
    some_string: str             # Text
    some_number: int             # Numbers
    some_boolean: bool           # Boolean
    some_date: datetime          # Timestamps
    some_array: List[str]        # Arrays
    
    # Optional fields
    optional_field: Optional[str] = None  # May not be present in all records
```
</Python>

### Advanced Schema Patterns

#### Nested Objects

<TypeScript>
```typescript filename="app/datamodels/NestedDataModel.ts"
import { Key } from "@514labs/moose-lib";

// Define nested object separately
interface NestedObject {
  nestedNumber: number;
  nestedBoolean: boolean;
  nestedArray: number[];
}

export interface DataModelWithNested {
  primaryKey: Key<string>;
  
  // Reference nested object
  nestedData: NestedObject;

  // Or define inline
  inlineNested: {
    someValue: string;
    someOtherValue: number;
  };
}
```
</TypeScript>

<Python>
```python filename="app/datamodels/NestedDataModel.py"
from moose_lib import Key
from typing import List
from pydantic import BaseModel, Field

class NestedObject(BaseModel):
    nested_number: int
    nested_boolean: bool
    nested_array: List[int]

class DataModelWithNested(BaseModel):
    primary_key: Key[str]
    nested_data: NestedObject
```
</Python>

#### Using Enums

<TypeScript>
```typescript filename="app/datamodels/EnumDataModel.ts"
import { Key } from "@514labs/moose-lib";

enum OrderStatus {
  PENDING = "pending",
  PROCESSING = "processing",
  COMPLETED = "completed"
}

export interface Order {
  orderId: Key<string>;
  status: OrderStatus;  // Type-safe status values
  createdAt: Date;
}
```
</TypeScript>

<Python>
```python filename="app/datamodels/EnumDataModel.py"
from enum import Enum
from moose_lib import Key
from datetime import datetime
from pydantic import BaseModel

class OrderStatus(str, Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"

class Order(BaseModel):
    order_id: Key[str]
    status: OrderStatus  # Type-safe status values
    created_at: datetime
```
</Python>

### Type Mapping

<TypeScript>
| TypeScript | ClickHouse | Description |
|------------|------------|-------------|
| `string` | String | Text values |
| `number` | Float64 | Numeric values |
| `number & tags.Type<"int64">` | Int64 | Integer values |
| `boolean` | Boolean | True/false values |
| `Date` | DateTime | Timestamp values |
| `Array` | Array | Lists of values |
| `object` | Nested | Nested structures |
| `Enum` | Enum | Enumerated values |
</TypeScript>

<Python>
| Python | ClickHouse | Description |
|--------|------------|-------------|
| `str` | String | Text values |
| `int` | Int64 | Integer values |
| `float` | Float64 | Decimal values |
| `bool` | Boolean | True/false values |
| `datetime` | DateTime | Timestamp values |
| `List[T]` | Array | Lists of values |
| `Enum` | Enum | Enumerated values |
| `Optional[T]` | Nullable | Values may be present or not |

</Python>

<Callout type="info" title="Schema Evolution">
When evolving your schemas, follow these guidelines:
- Add new fields as optional to maintain backward compatibility
- Avoid removing or renaming existing fields
- Consider creating a new version of your model for major changes
</Callout>

## Infrastructure Configuration

<Callout type="info" title="The HOW">
  This section covers how to apply your data models to infrastructure components.
</Callout>

### Component Types

You can use your data models with different infrastructure components:

#### Complete Ingestion Pipeline
The most common pattern - combines ingestion, streaming, and storage.

<TypeScript>
```ts filename="app/index.ts"
import { IngestPipeline } from "@514labs/moose-lib";

const myPipeline = new IngestPipeline<MyDataModel>("my_pipeline", {
    ingest: true,
    stream: true,
    table: true
});
```
</TypeScript>

<Python>
```python filename="app/index.py"
from moose_lib import IngestPipeline, IngestPipelineConfig

my_pipeline = IngestPipeline[MyDataModel]("my_pipeline", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True
))
```
</Python>

#### Individual Components

<Tabs items={['Database Tables', 'Streams', 'Ingest API', 'Materialized Views', 'Consumption APIs']}>
  <Tabs.Tab>
    <TypeScript>
    ```typescript filename="app/index.ts"
    import { OlapTable } from "@514labs/moose-lib";
    
    // Basic table
    const myTable = new OlapTable<MyDataModel>("MyTable");
    ```
    </TypeScript>
    
    <Python>
    ```python filename="app/index.py"
    from moose_lib import OlapTable
    
    # Basic table
    my_table = OlapTable[MyDataModel]("MyTable")
    ```
    </Python>
    More information on [Olap Tables](/moose/olap-table)
  </Tabs.Tab>
  
  <Tabs.Tab>
    <TypeScript>
    ```typescript filename="app/index.ts"
    import { Stream } from "@514labs/moose-lib";
    
    // Basic stream
    const myStream = new Stream<MyDataModel>("MyStream");
    ```
    </TypeScript>
    
    <Python>
    ```python filename="app/index.py"
    from moose_lib import Stream
    
    # Basic stream
    my_stream = Stream[MyDataModel]("MyStream")
    ```
    </Python>
    More information on [Streams](/moose/streams)
  </Tabs.Tab>
  
  <Tabs.Tab>
    <TypeScript>
    ```typescript filename="app/index.ts"
    import { IngestAPI } from "@514labs/moose-lib";
    
    const myIngestAPI = new IngestAPI<MyDataModel>("MyIngestAPI");
    ```
    </TypeScript>
    
    <Python>
    ```python filename="app/index.py"
    from moose_lib import IngestAPI
    
    my_ingest_api = IngestAPI[MyDataModel]("MyIngestAPI")
    ```
    </Python>
    More information on [Ingest APIs](/moose/ingestion)
  </Tabs.Tab>
  
  <Tabs.Tab>
    <TypeScript>
    ```typescript filename="app/index.ts"
    import { MaterializedView } from "@514labs/moose-lib";
    
    const myMaterializedView = new MaterializedView<MyDataModel>("MyMaterializedView");
    ```
    </TypeScript>
    
    <Python>
    ```python filename="app/index.py"
    from moose_lib import MaterializedView
    
    my_materialized_view = MaterializedView[MyDataModel]("MyMaterializedView")
    ```
    </Python>
    More information on [Materialized Views](/moose/materialized-views)
  </Tabs.Tab>
  
  <Tabs.Tab>
    <TypeScript>
    ```typescript filename="app/index.ts"
    import { ConsumptionAPI } from "@514labs/moose-lib";
    
    const myConsumptionAPI = new ConsumptionAPI<RequestDataModel, ResponseDataModel>("MyConsumptionAPI", (request: RequestDataModel) => {
      // Do something with the request
      return new ResponseDataModel();
    });
    ```
    </TypeScript>
    
    <Python>
    ```python filename="app/index.py"
    from moose_lib import ConsumptionAPI
    
    my_consumption_api = ConsumptionAPI[MyDataModel]("MyConsumptionAPI")
    ```
    </Python>
    More information on [Consumption APIs](/moose/consumption-apis)
  </Tabs.Tab>
</Tabs>

### Common Configuration Scenarios

#### Enabling Batch Ingestion

<TypeScript>
```typescript
const batchPipeline = new IngestPipeline<BatchDataModel>("batch_pipeline", {
  ingest: {
    format: IngestionFormat.JSON_ARRAY // Accept arrays of objects
  },
  stream: true,
  table: true
});
```
</TypeScript>

<Python>
```python
from moose_lib import DataModelConfig, IngestionConfig, IngestionFormat

batch_pipeline = IngestPipeline[BatchDataModel]("batch_pipeline", IngestPipelineConfig(
    ingestion=IngestionConfig(
        format=IngestionFormat.JSON_ARRAY  // Accept arrays of objects
    ),
    stream=True,
    table=True
))
```
</Python>

#### Optimizing Query Performance With Ordering

<TypeScript>
```typescript
import { Key, IngestPipeline, IngestPipelineConfig } from "@514labs/moose-lib";

export interface OrderByFieldsModel {
  userId: Key<string>;
  timestamp: Date;
  someOtherField: string;
  someOtherField2: number;
  someOtherField3: boolean;
}
const optimizedQueryPipeline = new IngestPipeline<OrderByFieldsModel>("optimized_pipeline", {
  ingest: true,
  stream: true,
  table: {
    orderByFields: ["userId", "timestamp"]  // Fields for optimized querying
  }
});
```
</TypeScript>

<Python>
```python
from moose_lib import IngestPipeline, IngestPipelineConfig

class OrderByFieldsModel(BaseModel):
    user_id: Key[str]
    timestamp: datetime
    some_other_field: str
    some_other_field2: int
    some_other_field3: bool

optimized_query_config = IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=StorageConfig(
        order_by_fields=["user_id", "timestamp"]  // Fields for optimized querying
    )
)
```
</Python>

#### Setting Up Deduplication

<TypeScript>
```typescript
interface UniqueModel {
  primaryKey: Key<string>;
  timestamp: Date;
  someOtherField: string;
  someOtherField2: number;
  someOtherField3: boolean;
}

const deduplicationPipeline = new IngestPipeline<UniqueModel>("deduplication_pipeline", {
  ingest: true,
  stream: true,
  table: {
    deduplicate: true,                         // Enable deduplication
    orderByFields: ["primaryKey", "timestamp"]  // Fields for deduplication
  }
});
```
</TypeScript>

<Python>
```python
from moose_lib import Key, IngestPipeline, IngestPipelineConfig
from pydantic import BaseModel

class UniqueModel(BaseModel):
    primary_key: Key[str]
    timestamp: datetime
    some_other_field: str
    some_other_field2: int
    some_other_field3: bool

deduplication_pipeline = IngestPipeline[UniqueModel]("deduplication_pipeline", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=StorageConfig(
        deduplicate=True,  // Enable deduplication
        order_by_fields=["primary_key", "timestamp"]  // Fields for deduplication
    )
))
```
</Python>

<Callout type="warning" title="Deduplication Caveats">
Deduplication uses ClickHouse's ReplacingMergeTree engine for eventual deduplication, meaning duplicate records may not be removed immediately. This process can take time and is not guaranteed to be immediate. For more details, see the [ClickHouse documentation](https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/replacingmergetree).
</Callout>

## Default Behaviors

If you don't specify configuration options:

1. Moose expects single JSON objects per request (not batches)
2. A ClickHouse table will be created for your data model
3. Deduplication will be disabled
4. If your model includes a field with the `Key` type, it will be used for ordering

## Next Steps

<FeatureGrid columns={3}>
  <FeatureCard
    href="/moose/streams"
    title="Streaming Deep Dive"
    description="Learn how to process, transform, and manage data streams in real-time."
  />
  <FeatureCard
    href="/moose/olap-table"
    title="Working with Tables"
    description="Discover how to optimize storage, querying, and analytics with OLAP tables."
  />
  <FeatureCard
    href="/moose/ingestion"
    title="Ingesting Data"
    description="Explore how to efficiently ingest data with automatic schema validation."
  />
</FeatureGrid>
