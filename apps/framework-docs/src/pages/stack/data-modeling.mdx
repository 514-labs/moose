---
title: Data Modeling
description: Data Modeling for Moose
---

import { Callout, LanguageSwitcher, TypeScript, Python, CTACards, CTACard, CheckmarkBullets, BulletPointsCard } from "@/components";
import { FileTree, Tabs } from "nextra/components";
import { PathConfig } from "@/components/ctas";

# Data Modeling
<LanguageSwitcher />

## Overview

Data models in Moose are type definitions that generate your data infrastructure. You write them as <TypeScript inline>TypeScript interfaces</TypeScript><Python inline>Pydantic models</Python>, export them from your app's root <TypeScript inline>index.ts</TypeScript><Python inline>main.py</Python> file, and Moose creates the corresponding database tables, APIs, and streams from your code.

### What is a Data Model?
A Moose data model is a single <TypeScript inline>TypeScript interface</TypeScript><Python inline>Pydantic model</Python> that becomes the authoritative source for **all** your infrastructure schemas:

- **ClickHouse Tables and Materialized Views** (automatically generated DDL)
- **Redpanda/Kafka Streams** (schema registry and topic validation)
- **HTTP APIs** (request/response validation and OpenAPI specs)
- **Workflow Tasks** (typed function inputs/outputs)

**What this means for you:**
- **Your code IS your schema**: Change a <TypeScript inline>TypeScript interface</TypeScript><Python inline>Pydantic model</Python>, and ClickHouse tables, Kafka topics, and APIs update automatically
- **Catch issues at dev-time**: Static type checking catches schema mismatches across systems at dev-time, not in production
- **One change, everywhere**: Add a field once and it's validated consistently across your entire data pipeline

<BulletPointsCard
  title="Working with Data Models"
  bullets={[
    {
      title: "Define your schema",
      description: "Create a type definition with typed fields and a primary key using your language's type system"
    },
    {
      title: "Create infrastructure",
      description: "Use your model as a type parameter to create tables, APIs, streams, or views"
    },
    {
      title: "Export from root",
      description: "Export all models and infrastructure from your app's root file (index.ts/main.py) - Moose reads these exports to generate infrastructure"
    },
    {
      title: "Run dev server",
      description: "When you create or modify data models, Moose automatically creates or updates all dependent infrastructure components with your latest code changes."
    }
  ]}
/>

## Getting Started with Data Models

### Step 1: Super Basic Data Model

<TypeScript>
```ts
export interface ExampleModel {
  stringField: string;
  numberField: number;
  dateField: Date;
}
```
</TypeScript>

<Python>
```python
from pydantic import BaseModel
from datetime import datetime

class ExampleModel(BaseModel):
    string_field: str
    number_field: float
    date_field: datetime
```
</Python>

### Step 2: Composite Types (No Advanced Rules)

<TypeScript>
```ts
export interface CompositeExample {
  stringField: string;
  numberField: number;
  nestedObject: {
    innerString: string;
    innerNumber: number;
  };
  numberArray: number[];
  mapField: Record<string, number>;
  jsonField: Record<string, any>;
  literalField: "optionA" | "optionB";
  optionalField?: string;
  nullableField: string | null;
  dateField: Date;
}
```
</TypeScript>

<Python>
```python
from pydantic import BaseModel
from typing import Optional, List, Dict, Any, Literal
from datetime import datetime

class NestedObject(BaseModel):
    inner_string: str
    inner_number: float

class CompositeExample(BaseModel):
    string_field: str
    number_field: float
    nested_object: NestedObject
    number_array: List[float]
    map_field: Dict[str, float]
    json_field: Dict[str, Any]
    literal_field: Literal["optionA", "optionB"]
    optional_field: Optional[str] = None
    nullable_field: Optional[str] = None
    date_field: datetime
```
</Python>

### Step 3: ClickHouse Optimizations with Type Annotations

**Purpose**: Database performance optimizations that don't affect your application code.

<TypeScript>
```ts
import { Key, ClickHouseDecimal, LowCardinality, ClickHouseNamedTuple } from "@514labs/moose-lib";

export interface ClickHouseOptimizedExample {
  id: Key<string>;
  stringField: string;
  numberField: number;
  decimalField: string & ClickHouseDecimal<10, 2>;      // Precise decimal storage
  lowCardinalityField: string & LowCardinality;         // Faster queries for enum-like data
  nestedObject: {
    innerString: string;
    innerNumber: number;
  };
  namedTupleField: {
    name: string;
    value: number;
  } & ClickHouseNamedTuple;                             // Optimized nested storage
  numberArray: number[];
  mapField: Record<string, number>;
  literalField: "optionA" | "optionB";
  optionalField?: string;
  dateField: Date;
}
```
</TypeScript>

**ClickHouse annotations:** Only used for database schema generation. Your TypeScript objects remain unchanged.

### Step 4: Runtime Validation with Tags

**Purpose**: Data validation rules that apply at API boundaries and ingestion points.

<TypeScript>
```ts
import { Key, tags } from "@514labs/moose-lib";

export interface ValidationExample {
  id: Key<string & tags.Format<"uuid">>;                // Must be valid UUID format
  email: string & tags.Format<"email">;                 // Must be valid email format
  age: number & tags.Minimum<0> & tags.Maximum<120>;    // Age range validation
  username: string & tags.MinLength<3> & tags.MaxLength<50>; // Length validation
  score: number & tags.Type<"int32"> & tags.Minimum<0> & tags.Maximum<100>; // Type + range
  website?: string & tags.Format<"uri">;                // Optional URL validation
  createdAt: Date;
}
```
</TypeScript>

**Validation tags:** Enforce data quality at runtime during ingestion and API calls.

### Quick Start

<TypeScript>
```ts filename="app/index.ts" copy
// 1. Define your schema (WHAT your data looks like)
interface MyDataModel {
  primaryKey: Key<string>;
  someString: string;
  someNumber: number;
  someDate: Date;
}

// 2. YOU control which infrastructure to create (HOW to handle your data)
const pipeline = new IngestPipeline<MyDataModel>("MyDataPipeline", {
  ingest: true,    // Optional: Create API endpoint
  stream: true,    // Optional: Create topic
  table: {         // Optional: Create and configure table
    orderByFields: ["primaryKey", "someDate"],
    deduplicate: true
  }
});
```
</TypeScript>

<Python>
```python filename="app/main.py"
# 1. Define your schema (WHAT your data looks like)
class MyFirstDataModel(BaseModel):
    id: Key[str] = Field(..., description="Primary key")
    some_string: str
    some_number: int
    some_boolean: bool
    some_date: datetime


# 2. YOU control which infrastructure to create (HOW to handle your data)
my_first_pipeline = IngestPipeline[MyFirstDataModel]("my_first_pipeline", IngestPipelineConfig(
    ingest=True,  # Create API endpoint
    stream=True,  # Create stream topic
    table=True    # Create database table
))
```
</Python>

<BulletPointsCard
  divider={false}
  bulletStyle="check"
  title="Benefits:"
  bullets={[
    "End-to-end type safety across your code and infrastructure",
    "Full control over your infrastructure with code",
    "Zero schema drift - change your types in one place, automatically update your infrastructure"
  ]}
/>

## Use Cases

### Modeling ClickHouse Tables, Views, and Materialized Views

<TypeScript>
```ts filename="app/datamodels/Order.ts"
import { Key, ClickHouseDecimal, LowCardinality, ClickHouseNamedTuple, tags } from "@514labs/moose-lib";

export interface Order {
  orderId: Key<string>; // Primary key
  amount: string & ClickHouseDecimal<10, 2>; // Decimal(10,2)
  status: string & LowCardinality; // LowCardinality(String)
  createdAt: Date; // DateTime
  customer: {
    name: string;
    address: string;
  } & ClickHouseNamedTuple; // NamedTuple
}
```

```ts filename="app/datamodels/Order.ts"
import { Key, ClickHouseDecimal, LowCardinality } from "@514labs/moose-lib";

export interface Order {
  orderId: Key<string>; // Primary key
  amount: number & ClickHouseDecimal<10, 2>; // Decimal(10,2)
  status: string & LowCardinality; // LowCardinality(String)
  createdAt: Date; // DateTime
}
```
**TypeScript with ClickHouse annotations:**
- Use union types like `& ClickHouseNamedTuple` as metadata annotations for database optimization
- Annotations are compile-time hints—they don't change your runtime TypeScript objects
- Moose reads these annotations to generate optimized ClickHouse schemas automatically
- Your application code uses the base type; annotations are stripped away outside table contexts

**Example:** `Customer & ClickHouseNamedTuple` is a regular `Customer` object in your app, but Moose generates a ClickHouse `NamedTuple` column for performance.
</TypeScript>

<Python>
```python filename="app/datamodels/Order.py"
from moose_lib import Key, clickhouse_decimal, ClickHouseNamedTuple
from typing import Annotated
from pydantic import BaseModel
from datetime import datetime

class Customer(BaseModel):
    name: str
    address: str

class Order(BaseModel):
    order_id: Key[str]
    amount: clickhouse_decimal(10, 2)
    status: str  # Use Literal[...] for LowCardinality
    created_at: datetime
    customer: Annotated[Customer, "ClickHouseNamedTuple"]
```

**Pydantic with ClickHouse annotations:**
- Use `Annotated[Customer, "ClickHouseNamedTuple"]` as metadata annotations for database optimization
- Annotations are type hints—they don't change your runtime Python objects
- Moose reads these annotations to generate optimized ClickHouse schemas automatically
- Your application code uses the base type; annotations are stripped away outside table contexts

**Example:** `Annotated[Customer, "ClickHouseNamedTuple"]` is a regular `Customer` object in your app, but Moose generates a ClickHouse `NamedTuple` column for performance.

</Python>


### Supported ClickHouse Types and Mappings

<TypeScript>
| Moose TypeScript Type                                 | ClickHouse Type             | Description                                |
|------------------------------------------------------|-----------------------------|---------------------------------------------|
| `Key\<string|number>`                                 | String, Int64 (Primary Key) | Primary key for table                      |
| `string`                                             | String                      | Text values                                 |
| `number`                                             | Float64                     | Numeric values                              |
| `boolean`                                            | Boolean                     | True/false values                           |
| `Date`                                               | DateTime                    | Timestamp values                            |
| `Array<T>`                                           | Array                       | Lists of values                             |
| `Record<K, V>`                                       | Map                         | Map of key-value pairs                      |
| `Enum`                                               | Enum                        | Enumerated values                           |
| `object` (Nested)                                    | Nested                      | Nested structures                           |
| `object & ClickHouseNamedTuple` (NamedTuple)         | NamedTuple                  | Named tuple structures                      |
| `string & LowCardinality`                            | LowCardinality(String)      | Low cardinality string                      |
| `number & tags.Type\<"int16" | "int32" | "int64">`   | Int16, Int32, UInt32, etc.  | Explicit integer types                      |
| `string & ClickHouseDecimal<P, S>`                   | Decimal(P, S)               | Decimal with precision/scale                |
| `Optional<T>`                                        | Nullable(T)                 | Optional/nullable fields (with restrictions)|


</TypeScript>

<Python>
| Moose Python Type                                    | ClickHouse Type             | Description                                 |
|------------------------------------------------------|-----------------------------|---------------------------------------------|
| `Key[str|int]`                                       | String, Int64 (Primary Key) | Primary key for table                       |
| `str`                                                | String                      | Text values                                 |
| `int`                                                | Int                         | Integer values (default)                   |
| `Annotated[int, "int8"]`                             | Int8                        | 8-bit signed integer                        |
| `Annotated[int, "int16"]`                            | Int16                       | 16-bit signed integer                       |
| `Annotated[int, "int32"]`                            | Int32                       | 32-bit signed integer                       |
| `Annotated[int, "int64"]`                            | Int64                       | 64-bit signed integer                       |
| `float`                                              | Float64                     | 64-bit floating point values               |
| `Annotated[float, ClickhouseSize(size=4)]`           | Float32                     | 32-bit floating point values               |
| `Decimal`                                            | Decimal(10, 0)              | Arbitrary-precision decimal (default)       |
| `clickhouse_decimal(precision, scale)`               | Decimal(precision, scale)   | Decimal with specific precision/scale       |
| `bool`                                               | Boolean                     | True/false values                           |
| `datetime`                                           | DateTime                    | Timestamp values                            |
| `clickhouse_datetime64(precision)`                   | DateTime64(precision)       | Timestamp with specific precision           |
| `date`                                               | Date                        | Date values                                 |
| `Annotated[date, ClickhouseSize(size=2)]`            | Date16                      | 16-bit date values                          |
| `UUID`                                               | UUID                        | UUID values                                 |
| `ipaddress.IPv4Address`                              | IPv4                        | IPv4 addresses                              |
| `ipaddress.IPv6Address`                              | IPv6                        | IPv6 addresses                              |
| `Any`                                                | Json                        | JSON data                                   |
| `List[T]`                                            | Array                       | Lists of values                             |
| `Dict[K, V]`                                         | Map                         | Map of key-value pairs                      |
| `Enum`                                               | Enum                        | Enumerated values                           |
| `BaseModel` (Nested)                                 | Nested                      | Nested structures                           |
| `Annotated[BaseModel, "ClickHouseNamedTuple"]`       | NamedTuple                  | Named tuple structures                      |
| `Literal[...]`                                       | LowCardinality(String)      | Low cardinality string                      |
| `Optional[T]`                                        | Nullable(T)                 | Optional/nullable fields (with restrictions)|
</Python>


### Common Data Modeling Mistakes and Workarounds

<TypeScript>
```ts filename="app/datamodels/AnyFields.ts" copy
// ❌ DO NOT: Use unknown type for flexible fields
interface BadDataModel {
  unknownField: unknown;
}
```
```ts filename="app/datamodels/AnyFields.ts" copy
// ✅ DO: Use a specific type or JSON type if truly needed
interface GoodDataModel {
  jsonField: Record<string, any>; //For storing arbitrary JSON
}
```

```ts filename="app/datamodels/FlexibleFields.ts" copy
// ❌ DO NOT: Use union types for flexible fields
interface BadDataModel {
  conditionalField: string | number;
}
```
```ts filename="app/datamodels/FlexibleFields.ts" copy
// ✅ DO: Use optional fields for flexibility and nullability
interface GoodDataModel {
  conditionalString?: string;
  conditionalNumber?: number;
}
```

```ts filename="app/datamodels/OptionalNested.ts" copy
// ❌ DO NOT: Use Nullable with composite types (arrays, maps, nested, namedtuple)
interface BadDataModel {
  nullableNested?: {
    nestedField: string;
  };
  nullableNamedTuple?: {
    nestedField: string;
  } & ClickHouseNamedTuple;
  nullableArray?: T[];
  nullableMap?: Record<K, T>;
}
```
```ts filename="app/datamodels/OptionalNested.ts" copy
// ✅ DO: Use optional fields inside composite types
interface GoodDataModel {
  nested: {
    nestedField?: string;
  };
  namedTuple: {
    nestedField?: string;
  } & ClickHouseNamedTuple;
  array: (T | undefined)[];
  map: Record<K, T>;
}
```
</TypeScript>

<Python>
```python filename="app/datamodels/FlexibleFields.py"
# ❌ DO NOT: Use union types for flexible fields
class BadDataModel(BaseModel):
    flexible_field: Union[str, int]
```
```python filename="app/datamodels/FlexibleFields.py"
# ✅ DO: Use Any for flexible fields and Optional for nullable fields
class GoodDataModel(BaseModel):
    flexible_field: Any  # Maps to JSON type in ClickHouse
```

```python filename="app/datamodels/OptionalNested.py"
# ❌ DO NOT: Use Optional with composite types
class BadDataModel(BaseModel):
    nested_data: Optional[NestedObject]
    named_tuple: Optional[Annotated[Coordinates, ClickHouseNamedTuple]]
    array: Optional[List[int]]
    map: Optional[Dict[str, int]]
```
```python filename="app/datamodels/OptionalNested.py"
# ✅ DO: Use Optional fields inside composite types
class GoodDataModel(BaseModel):
    nested_data: NestedObject  # with optional fields inside
    named_tuple: Annotated[Coordinates, ClickHouseNamedTuple]  # with optional fields inside
    array: List[Optional[int]]
    map: Dict[str, int]
```
</Python>

---

## Modeling APIs: Request and Response Validation

Data models are also used to define the shape of data accepted by and returned from your Ingest and Consumption API endpoints. 

### Ingest API
When requests are made to the Ingest API, the request body is validated against the data model.
<TypeScript>
```ts filename="app/datamodels/ApiRequest.ts"
export interface CreateUserRequest {
  username: string;
  email: string;
  age?: number;
}

const ingest_api = new IngestAPI<CreateUserRequest>("create-user")
```
</TypeScript>

<Python>
```python filename="app/datamodels/ApiRequest.py"
from pydantic import BaseModel

class CreateUserRequest(BaseModel):
    username: str
    email: str
    age: int | None = None

ingest_api = IngestAPI[CreateUserRequest]("create-user")
```
</Python>

### Consumption API
When requests are made to the Consumption API, the URL params are validated against the data model. The response body is validated against the response data model.

<TypeScript>
```ts filename="app/apis/metrics.ts"
import { ConsumptionAPI } from "@514labs/moose-lib";

interface QueryParams {
  entityId: string;
  startDate: string; // ISO date string
  endDate: string;   // ISO date string
}

interface AnalyticsResponse {
  totalCount: number;
  averageValue: number;
  aggregatedData: Record<string, number>;
}

// GET /consumption/metrics?entityId=123&startDate=2024-01-01&endDate=2024-01-31
const metricsAPI = new ConsumptionAPI<QueryParams, AnalyticsResponse>("metrics")
```
</TypeScript>


## Modeling Kafka/Redpanda Streams

Data Models are also used to define the shape of data published to and consumed from Kafka/Redpanda topics. When a stream connects to an `OlapTable`, Moose ensures the stream schema, ClickHouse table schema, and any API schemas are perfectly synchronized.


<TypeScript>
```ts filename="app/datamodels/Event.ts"
export interface Event {
  eventId: string;
  timestamp: Date;
  payload: Record<string, any>;
}

const stream = new Stream<Event>("my-stream", {
  destination: new OlapTable<Event>("my-table")
})


stream.addConsumer((event: Event) => {
  // COMING SOON: validators for events
  stream.validate(event) 
})
```
</TypeScript>

<Python>
```python filename="app/datamodels/Event.py"
from pydantic import BaseModel
from datetime import datetime
from typing import Any

class Event(BaseModel):
    event_id: str
    timestamp: datetime
    payload: dict[str, Any]

stream = Stream[Event]("stream")
stream.add_consumer(lambda event: Event.model_validate(event))
```
</Python>
---

## Modeling Workflow Tasks: Inputs and Outputs

<Callout type="info" title="Workflow Tasks: Type Safety for Function Inputs and Outputs">
  Use data models to define the input and output types for workflow tasks (functions, jobs, etc.). Moose validates task inputs and outputs at runtime using your data model.
</Callout>

<TypeScript>
```ts filename="app/datamodels/TaskInput.ts"
interface TaskInput {
  userId: string;
  action: string;
  metadata?: Record<string, any>;
}

interface TaskOutput {
  success: boolean;
  message: string;
}

const task = new Task<TaskInput, TaskOutput>("task", {
  run: async (input): Promise<TaskOutput> => {
    return {
      success: true,
      message: "Task completed successfully",
    };
  },
});
```
</TypeScript>

<Python>
```python filename="app/datamodels/TaskInput.py"
from pydantic import BaseModel
from typing import Optional, Dict, Any

class TaskInput(BaseModel):
    user_id: str
    action: str
    metadata: Optional[Dict[str, Any]] = None

class TaskOutput(BaseModel):
    success: bool
    message: str

def handle_task(input_data: TaskInput) -> TaskOutput:
    return TaskOutput(
        success=True,
        message="Task completed successfully"
    )

task = Task[TaskInput, TaskOutput]("task", run_function=handle_task)
```
</Python>

## Schema Definition

<Callout type="info" title="The WHAT">
  This section covers how to define your data models - the structure and types of your data.
</Callout>

### Basic Types

<TypeScript>
```ts filename="app/datamodels/BasicDataModel.ts" copy
import { Key } from "@514labs/moose-lib";
import { tags } from "typia";
import { ClickHouseDecimal, ClickHousePrecision, LowCardinality } from "@514labs/moose-lib";

export interface BasicDataModel {
  // Required: Primary key for your data model
  primaryKey: Key<string>;    // string key
  // or
  numericKey: Key<number>;    // numeric key

  // Common types
  someString: string;         // Text
  someNumber: number;         // Numbers (Float64 by default)
  someBoolean: boolean;       // Boolean
  someDate: Date;             // Timestamps (DateTime)
  someArray: string[];        // Arrays
  someJsonObject: Record<string, any>;        // JSON object 

  // Explicit integer types
  intField: number & tags.Type<"int64">;   // Int64
  uintField: number & tags.Type<"uint32">; // UInt32

  // Decimal with precision/scale
  price: ClickHouseDecimal<10, 2>;         // Decimal(10,2)

  // DateTime64 with precision
  eventTime: Date & ClickHousePrecision<6>; // DateTime64(6)

  // UUID
  userId: string & tags.Type<"uuid">;      // UUID

  // Nullable fields
  nullableField?: string;  // Optional field

  // LowCardinality
  lowCardinalityField: string & LowCardinality; // LowCardinality(String)
}
```
</TypeScript>

<Python>
You use Pydantic to define your schemas:

```python filename="app/datamodels/BasicDataModel.py"
from moose_lib import Key, clickhouse_decimal, clickhouse_datetime64
from datetime import datetime, date
from typing import List, Optional, Any, Annotated
from uuid import UUID
from pydantic import BaseModel, Field
from decimal import Decimal

class BasicDataModel(BaseModel):
    # Required: Primary key for your data model
    primary_key: Key[str]
    # or
    numeric_key: Key[int]
    
    # Common types
    some_string: str             # Text
    some_number: int             # Numbers (Int64 by default)
    some_boolean: bool           # Boolean
    some_date: datetime          # Timestamps (DateTime)
    some_array: List[str]        # Arrays
    some_json_object: Any        # JSON object

    # Explicit integer types
    small_int: Annotated[int, "int16"]   # Int16
    big_uint: Annotated[int, "uint64"]   # UInt64

    # Decimal with precision/scale
    price: clickhouse_decimal(10, 2)     # Decimal(10,2)

    # DateTime64 with precision
    event_time: clickhouse_datetime64(6) # DateTime64(6)

    # UUID
    user_id: UUID                        # UUID

    # Optional fields
    optional_field: Optional[str] = None  # May not be present in all records

    # LowCardinality
    low_cardinality_field: Annotated[str, "LowCardinality"]
```
</Python>

### Advanced Schema Patterns

#### Nested Objects

<TypeScript>
```ts filename="app/datamodels/NestedDataModel.ts" copy
import { Key } from "@514labs/moose-lib";

// Define nested object separately
interface NestedObject {
  nestedNumber: number;
  nestedBoolean: boolean;
  nestedArray: number[];
}

export interface DataModelWithNested {
  primaryKey: Key<string>;
  
  // Reference nested object
  nestedData: NestedObject;

  // Or define inline
  inlineNested: {
    someValue: string;
    someOtherValue: number;
  };
}
```
</TypeScript>

<Python>
```python filename="app/datamodels/NestedDataModel.py"
from moose_lib import Key
from typing import List
from pydantic import BaseModel, Field

class NestedObject(BaseModel):
    nested_number: int
    nested_boolean: bool
    nested_array: List[int]

class DataModelWithNested(BaseModel):
    primary_key: Key[str]
    nested_data: NestedObject
```
</Python>

#### Using Enums

<TypeScript>
```ts filename="app/datamodels/EnumDataModel.ts" copy
import { Key } from "@514labs/moose-lib";

enum OrderStatus {
  PENDING = "pending",
  PROCESSING = "processing",
  COMPLETED = "completed"
}

export interface Order {
  orderId: Key<string>;
  status: OrderStatus;  // Type-safe status values
  createdAt: Date;
}
```
</TypeScript>

<Python>
```python filename="app/datamodels/EnumDataModel.py"
from enum import Enum
from moose_lib import Key
from datetime import datetime
from pydantic import BaseModel

class OrderStatus(str, Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"

class Order(BaseModel):
    order_id: Key[str]
    status: OrderStatus  # Type-safe status values
    created_at: datetime
```
</Python>

### Type Mapping

<TypeScript>
| TypeScript | ClickHouse | Description |
|------------|------------|-------------|
| `string` | String | Text values |
| `number` | Float64 | Numeric values |
| `number & tags.Type<"int64">` | Int64 | 64-bit integer |
| `number & tags.Type<"uint32">` | UInt32 | 32-bit unsigned integer |
| `boolean` | Boolean | True/false values |
| `Date` | DateTime | Timestamp values |
| `Date & ClickHousePrecision<P>` | DateTime64(P) | Timestamp with precision |
| `ClickHouseDecimal<P, S>` | Decimal(P, S) | Decimal with precision/scale |
| `string & tags.Type<"uuid">` | UUID | Universally unique identifier |
| `Array` | Array | Lists of values |
| `object` | Nested | Nested structures |
| `Enum` | Enum | Enumerated values |
| `any` | JSON | JSON object (discouraged, see below) |
| `Optional<T>` | Nullable | Optional/nullable fields |
| `object & ClickHouseNamedTuple` | NamedTuple | Named tuple structures |
| `Record<K, V>` | Map | Map of key-value pairs |
| `string & LowCardinality` | LowCardinality(String) | Low cardinality string |
</TypeScript>

<Python>
| Python | ClickHouse | Description |
|--------|------------|-------------|
| `str` | String | Text values |
| `int` | Int64 | Integer values |
| `Annotated[int, "int16"]` | Int16 | 16-bit integer |
| `Annotated[int, "uint64"]` | UInt64 | 64-bit unsigned integer |
| `float` | Float64 | Decimal values |
| `Decimal` | Decimal | Arbitrary-precision decimal |
| `clickhouse_decimal(p, s)` | Decimal(p, s) | Decimal with precision/scale |
| `bool` | Boolean | True/false values |
| `datetime` | DateTime | Timestamp values |
| `clickhouse_datetime64(p)` | DateTime64(p) | Timestamp with precision |
| `date` | Date | Date values |
| `List[T]` | Array | Lists of values |
| `UUID` | UUID | Universally unique identifier |
| `Any` | JSON | Any value, use with caution |
| `Enum` | Enum | Enumerated values |
| `Optional[T]` | Nullable | Values may be present or not |
| Nested Pydantic | Nested | Nested structures |
</Python>

### Data Modeling Dos and Don'ts

<TypeScript>
Do not use `unknown` types for flexible fields (prefer explicit types or `any` for JSON):
```ts filename="app/datamodels/AnyFields.ts" copy
interface BadDataModel {
  unknownField: unknown;
}
```
```
// DO -> Use a specific type or a JSON type if truly needed
interface GoodDataModel {
  jsonField: any; // Only if you need to store arbitrary JSON
}
```
</TypeScript>

Do not use union types for flexible or nullable fields:

<TypeScript>
```ts filename="app/datamodels/FlexibleFields.ts"
// DO NOT -> Use union types for conditional fields
interface BadDataModel {
  conditionalField: string | number;
}

// DO -> break out into multiple optional fields
interface GoodDataModel {
  conditionalString?: string; // Optional field
  conditionalNumber?: number; // Optional field
}
```
```ts filename="app/datamodels/NullableFields.ts"
// DO NOT -> Use union types for nullable fields
interface BadDataModel {
  nullableField: string | null;
}

// DO -> Use Optional type
interface GoodDataModel { 
  nullableField?: string;
}
```
</TypeScript>

<Python>
```python filename="app/datamodels/FlexibleFields.py"
# DO NOT -> Use union types for flexible fields
class BadDataModel(BaseModel):
    flexible_field: Union[str, int]

# DO -> Use Any type for flexible fields
class FlexibleDataModel(BaseModel):
    flexible_field: Any # Maps to JSON type in ClickHouse
```
```python filename="app/datamodels/NullableFields.py"
# DO NOT -> Use union types for nullable fields
class BadDataModel(BaseModel):
    nullable_field: Union[str, None]

# DO -> Use Optional type
class GoodDataModel(BaseModel):
    nullable_field: Optional[str]
```
```python filename="app/datamodels/DictFields.py"
# DO NOT -> Use dict types for nested fields
class BadDataModel(BaseModel):
    dict_field: dict[str, Any]

class NestedObject(BaseModel):
    nested_field: str

# DO -> Use Nested type (Pydantic model)
class GoodDataModel(BaseModel):
    dict_field: NestedObject
```
</Python>


## Infrastructure Configuration

<Callout type="info" title="The HOW">
  This section covers how to apply your data models to infrastructure components.
</Callout>

### Getting Data Into Your Database

#### `IngestPipeline`
The most common pattern - combines ingestion, streaming, and storage into a single component:

<TypeScript>
```ts filename="app/index.ts"
import { IngestPipeline } from "@514labs/moose-lib";

const myPipeline = new IngestPipeline<MyDataModel>("my_pipeline", {
    ingest: true,
    stream: true,
    table: true
});
```
</TypeScript>

<Python>
```python filename="app/index.py"
from moose_lib import IngestPipeline, IngestPipelineConfig

my_pipeline = IngestPipeline[MyDataModel]("my_pipeline", IngestPipelineConfig(
    ingest=True,
    stream=True,
    table=True
))
```
</Python>

<BulletPointsCard
  divider={false}
  bulletStyle="check"
  title="What gets created?"
  bullets={[
    "An HTTP POST endpoint that accepts and validates incoming data against your data model",
    "A typed Redpanda topic that buffers validated data from the ingest API",
    "A ClickHouse table with the same schema as your data model",
    "A Rust process that syncs data from the stream to the table"
  ]}
/>
#### Standalone Components
If you don't need all the components, you can create them individually and wire them together yourself:

##### `OlapTable`
    Creates a ClickHouse table with the same schema as your data model:
    <TypeScript>
    ```typescript filename="app/index.ts"
    import { OlapTable } from "@514labs/moose-lib";
    
    // Basic table
    const myTable = new OlapTable<MyDataModel>("TableName");
    ```
    </TypeScript>
    
    <Python>
    ```python filename="app/index.py"
    from moose_lib import OlapTable
    
    # Basic table
    my_table = OlapTable[MyDataModel]("TableName")
    ```
    </Python>

    <Callout type="info" title="Olap Tables">
      You might use an OlapTable if you do not need streaming ingest capabilities for your data.
      [Learn more about Olap Tables](/moose/building/olap-table)
    </Callout>
  
##### `Stream`
Creates a Redpanda topic that can be configured to sync data to a ClickHouse table with the same schema:
<TypeScript>
```ts filename="app/index.ts" copy
import { Stream } from "@514labs/moose-lib";

// Basic stream
const myStream = new Stream<MyDataModel>("TopicName");
```
</TypeScript>

<Python>
```python filename="app/index.py"
from moose_lib import Stream

# Basic stream
my_stream = Stream[MyDataModel]("TopicName")
```
</Python>

<Callout type="info" title="Streams">
  Standalone streams may make sense if you want to transform data on the fly before it is written to the table. [Learn more about stream processing](/moose/building/streams)
</Callout>
  
##### `IngestAPI`
Creates an HTTP `POST` endpoint at "/ingest/api-route-name" that accepts and validates incoming data against your data model:
<TypeScript>
```ts filename="app/index.ts" copy
import { IngestAPI } from "@514labs/moose-lib";

const myIngestAPI = new IngestAPI<MyDataModel>("api-route-name"); // Creates an HTTP `POST` endpoint at "/ingest/api-route-name"
```
</TypeScript>

<Python>
```python filename="app/index.py"
from moose_lib import IngestAPI

my_ingest_api = IngestAPI[MyDataModel]("api-route-name")
```
</Python>
<Callout type="info" title="Ingest APIs">
  Ingest APIs are almost always preferred as part of an `IngestPipeline` instead of being used standalone. [Learn more about Ingestion APIs](/moose/building/ingestion)
</Callout>

### Getting Data Out of Your Database
Data models also power your downstream data processing workflows after data is stored, enabling you to create materialized views and typed APIs that prepare and expose your data for consumption:

#### `MaterializedView`
Materialized views are a way to pre-compute and store the results of complex queries on your data. This allows you to query the materialized view directly for faster results, or use it as the source for another derived table for cascading transformations:
<TypeScript>
```ts filename="app/index.ts" copy
import { MaterializedView } from "@514labs/moose-lib";

const myMaterializedView = new MaterializedView<MyDataModel>({
  selectStatement: sql`SELECT * FROM my_table`,
  tableName: "my_table",
  materializedViewName: "my_materialized_view"
});
```
</TypeScript>

<Python>
```python filename="app/index.py"
from moose_lib import MaterializedView

my_materialized_view = MaterializedView[MyDataModel](
  select_statement="SELECT * FROM my_table",
  table_name="my_table",
  materialized_view_name="my_materialized_view"
)
```
</Python>
<Callout type="info" title="Materialized Views">
  [Learn more about Materialized Views](/moose/building/materialized-views)
</Callout>

#### `ConsumptionAPI`
Consumption APIs are a way to expose your data to external consumers. They are typed and validateagainst your data models, ensuring that the client request parameters and response types are correct at runtime:

<TypeScript>
```ts filename="app/index.ts" copy
import { ConsumptionAPI } from "@514labs/moose-lib";

const myConsumptionAPI = new ConsumptionAPI<RequestDataModel, ResponseDataModel>("MyConsumptionAPI"async({request: RequestDataModel}, {client, sql}) => {
      // Do something with the request
  return new ResponseDataModel();
});
```
</TypeScript>

<Python>
```python filename="app/index.py"
from moose_lib import ConsumptionAPI

def handle(request: RequestDataModel) -> ResponseDataModel:
    # Do something with the request
    return ResponseDataModel()

my_consumption_api = ConsumptionAPI[RequestDataModel, ResponseDataModel]("api_route_name"query_function=handle)
    ```
</Python>

<Callout type="info" title="Consumption APIs">
  [Learn more about Consumption APIs](/moose/building/consumption-apis)
</Callout>

## Validation
Validation at runtime takes place at the following points:
- The body of a `POST` request to an `IngestAPI` endpoint - [Learn more about Ingestion APIs](/moose/building/ingestion#validation)
- The query parameters sent in a `GET` request to a Consumption API - [Learn more about Consumption APIs](/moose/building/consumption-apis#adding-advanced-type-validation)
- The data being synced from a streaming topic to an `OlapTable` - [Learn more about Olap Tables](/moose/building/olap-table)


## Next Steps

<CTACards rows={3}>
  <CTACard
    ctaLink={PathConfig.streams.path}
    ctaLabel="Learn More"
    icon={PathConfig.streams.icon}
    title="Streaming Deep Dive"
    description="Learn how to process, transform, and manage data streams in real-time."
    orientation="horizontal"
  />
  <CTACard
    ctaLink={PathConfig.olapTables.path}
    ctaLabel="Learn More"
    icon={PathConfig.olapTables.icon}
    title="Working with Tables"
    description="Discover how to optimize storage, querying, and analytics with OLAP tables."
    orientation="horizontal"
  />
  <CTACard
    ctaLink={PathConfig.ingestion.path}
    ctaLabel="Learn More"
    icon={PathConfig.ingestion.icon}
    title="Ingesting Data"
    description="Explore how to efficiently ingest data with automatic schema validation."
    orientation="horizontal"
  />
</CTACards>
