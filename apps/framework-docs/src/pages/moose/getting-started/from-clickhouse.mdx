import { Tabs, Steps, Card, FileTree } from "nextra/components";
import { Callout, FeatureCard, FeatureGrid, ToggleBlock, ZoomImg, Python, TypeScript, LanguageSwitcher, MuxVideo, BulletPointsCard } from "@/components";
import { Database, FileCode, Download, Zap } from "lucide-react";

# Start With Your ClickHouse Database

<LanguageSwitcher />

<Callout type="warning" title="Beta Feature">
This feature is in beta. Tables with unsupported types are skipped during initialization. See [Current Limitations](#current-limitations) for supported types.
</Callout>

Bootstrap a Moose project directly from your existing ClickHouse database in minutes.

## Why Use Moose with ClickHouse?

ClickHouse is a blazingly-fast analytical database, but with the power comes complexity and a lot of manual work:

<BulletPointsCard
  title="Manually Managing ClickHouse?"
  bulletStyle="x"
  bullets={[
    {
      title: "Copy-pasting DDL between environments",
      description: "Running the same CREATE TABLE and CREATE MATERIALIZED VIEW statements in dev, staging, and prod, hoping you didn't miss a field",
    },
    {
      title: "Forgetting dependency order",
      description: "Creating a materialized view before its source table exists, then scrambling to figure out what broke",
    },
    {
      title: "Lost schema changes",
      description: "That ALTER TABLE you ran last week? Good luck remembering what it was when you need to apply it to production",
    },
  ]}
/>

Moose provides a code layer on top of your existing ClickHouse database.

<BulletPointsCard
  bulletStyle="check"
  divider={false}
  title="How Moose Can Speed Things Up:"
  bullets={[
    {
      title: "Reduce boilerplate",
      description: "Generate typed models from your existing tables instead of hand-coding everything",
    },
    {
      title: "Build APIs in code, not Jinja templates",
      description: "Write TypeScript/Python functions with proper IDE support instead of templated SQL",
    },
    {
      title: "Add streaming with one line of code",
      description: "Turn any table into a real-time streaming destination without configuring Kafka topics, serialization, or message schemas",
    },
    {
      title: "Version control your database",
      description: "Manage schema changes, materialized views, and transformations like actual code",
    },
    {
      title: "Leverage CI/CD built for ClickHouse",
      description: "See a plan for your database changes before promoting to production, and apply them automatically when you do",
    },
  ]}
/>

## Quick Setup
<Callout type="info" title="Prerequisites">
<TypeScript>
- **Node.js**: [version 20+](https://nodejs.org/en/download) (LTS recommended)
</TypeScript>

<Python>
- **Python**: [version 3.12+](https://www.python.org/downloads/) 
</Python>

- **OS**: macOS or Linux (WSL supported for Windows)
- **Docker Desktop/Engine**: [24.0.0+](https://docs.docker.com/get-started/get-docker/)
- **Access to ClickHouse Database**: Connection URL with credentials
</Callout>

<Steps>

### Get Your ClickHouse Connection String

You need a ClickHouse connection URL. Format looks like this:

```
http://username:password@host:port/?database=database_name
```

<Callout type="info" title="Try with ClickHouse Playground">
Want to test without your own ClickHouse? Use the [ClickHouse Playground](https://clickhouse.com/docs/getting-started/playground) with the connection string above. It has sample datasets (read-only) you can experiment with.

```txt copy
https://explorer:@play.clickhouse.com:443/?database=default
```

</Callout>


<ToggleBlock openText="Need help finding credentials?" closeText="Hide credential help">
<Tabs items={["ClickHouse Cloud", "Self-Hosted", "Docker"]}>
<Tabs.Tab>
1. Log into your [ClickHouse Cloud console](https://clickhouse.cloud/)
2. Go to your service details page
3. Find "Connect" or "Connection Details" section
4. Copy the HTTPS endpoint and your username/password
</Tabs.Tab>
<Tabs.Tab>
- Check your ClickHouse config file (usually `/etc/clickhouse-server/config.xml`)
- Look for `<http_port>` (default: 8123) and `<https_port>` (default: 8443)
- Check users config in `/etc/clickhouse-server/users.xml` or users.d/ directory
- Default user is often `default` with no password
</Tabs.Tab>
<Tabs.Tab>
- Check your docker-compose.yml or docker run command for environment variables
- Look for `CLICKHOUSE_USER`, `CLICKHOUSE_PASSWORD`, `CLICKHOUSE_DB`
- Default is usually `http://default:@localhost:8123/?database=default`
</Tabs.Tab>
</Tabs>
</ToggleBlock>

<ToggleBlock openText="Common Issues" closeText="Hide Common Issues">

- **Can't connect?** Try `curl http://your-host:8123/ping` to test connectivity
- **Authentication failed?** Verify username/password with `clickhouse-client --user=username --password=password`
- **Database not found?** Run `SHOW DATABASES` to see available databases
- **Permission denied?** Check user permissions with `SHOW GRANTS FOR username`

**Still stuck?** Check the [ClickHouse documentation](https://clickhouse.com/docs/en/getting-started/install) for your specific deployment method.

</ToggleBlock>


### Install Moose & Bootstrap Your Project

Install Moose if you haven't already:
```bash copy
# Install Moose
bash -i <(curl -fsSL https://fiveonefour.com/install.sh) moose
```

Create a new project:
<Python>
```bash copy
# Bootstrap from your ClickHouse database
moose init my-project --from-remote <YOUR_CLICKHOUSE_CONNECTION_STRING> --language python

# Set up dependencies
cd my-project
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```
</Python>

<TypeScript>
```bash copy
# Bootstrap from your ClickHouse database
moose init my-project --from-remote <YOUR_CLICKHOUSE_CONNECTION_STRING> --language typescript

# Set up dependencies
cd my-project
npm install
```
</TypeScript>

### Start Your Local Environment

```bash copy
moose dev
```

This spins up your entire data stack locally and generates typed models from your ClickHouse tables.

### Check What Got Generated

Moose created data models for each of your ClickHouse tables. Check <Python inline>`app/main.py`</Python><TypeScript inline>`app/index.ts`</TypeScript> to see what you got.

<Python>
<FileTree>
<FileTree.Folder name="app" defaultOpen>
<FileTree.File name="main.py" />
</FileTree.Folder>
<FileTree.File name="moose.config.toml" />
<FileTree.File name="requirements.txt" />
<FileTree.File name="setup.py" />
</FileTree>
</Python>

<TypeScript>
<FileTree>
<FileTree.Folder name="app" defaultOpen>
<FileTree.File name="index.ts" />
</FileTree.Folder>
<FileTree.File name="moose.config.toml" />
<FileTree.File name="package.json" />
</FileTree>
</TypeScript>

</Steps>

## Type Mapping

Moose automatically maps ClickHouse data types to appropriate language-specific types:

<Python>

| ClickHouse Type | Python Type | Notes |
|-----------------|-------------|-------|
| `String` | `str` | |
| `Int8`, `Int16`, `Int32`, `Int64` | `int` | With size annotations |
| `UInt8`, `UInt16`, `UInt32`, `UInt64` | `int` | With size annotations |
| `Float32`, `Float64` | `float` | With precision annotations |
| `Decimal(P,S)` | `Decimal` | With precision/scale |
| `Date`, `Date32` | `date` | |
| `DateTime`, `DateTime64` | `datetime` | With precision for DateTime64 |
| `Array(T)` | `list[T]` | Nested type mapping |
| `UUID` | `UUID` | |
| `Boolean` | `bool` | |
| `Nullable(T)` | `Optional[T]` | |
| `LowCardinality(T)` | `T` | Maps to base type |
| `JSON` | `any` | Partial support |

</Python>
<TypeScript>

| ClickHouse Type | TypeScript Type | Notes |
|-----------------|-----------------|-------|
| `String` | `string` | |
| `Int8`, `Int16`, `Int32`, `Int64` | `number` | |
| `UInt8`, `UInt16`, `UInt32`, `UInt64` | `number` | |
| `Float32`, `Float64` | `number` | |
| `Decimal(P,S)` | `number` | |
| `Date`, `Date32` | `Date` | |
| `DateTime`, `DateTime64` | `Date` | |
| `Array(T)` | `T[]` | Nested type mapping |
| `UUID` | `string` | |
| `Boolean` | `boolean` | |
| `Nullable(T)` | `T \| null` | |
| `LowCardinality(T)` | `T` | Maps to base type |
| `JSON` | `Record<string, any>` | Partial support |

</TypeScript>

## What's Next?

Now that you've got Moose talking to your ClickHouse database:

### 1. Get Some Data Locally

```bash copy
# CLI command to seed from remote ClickHouse
moose seed from-remote-clickhouse <YOUR_CLICKHOUSE_CONNECTION_STRING> --rows 100
```


### 2. Build Materialized Views

Moose Materialized View abstraction helps speed things up for building and maintaining your transformation layer in ClickHouse:

<BulletPointsCard
  bulletStyle="check"
  divider={false}
  title="What you'll actually build:"
  bullets={[
    {
      title: "Schema + SELECT only",
      description: "Define your target model and SELECT statement - Moose generates DDL and sets up materialized view triggers automatically",
    },
    {
      title: "Type-safe aggregations",
      description: "Aggregated<\"sum\", [number]> types catch mismatches between your code and ClickHouse schemas at compile time",
    },
    {
      title: "Auto dependency order",
      description: "Reference source tables directly in SELECT statements - Moose figures out correct execution order",
    },
    {
      title: "Hot-reload development",
      description: "Change view logic and see it applied to local ClickHouse instantly, no manual DROP/CREATE cycles",
    },
  ]}
/>

<Callout type="info" title="Learn More">
Check out the [Materialized Views docs](/moose/building/materialized-views) for the full implementation guide.
</Callout>

### 3. Create APIs Your Frontend Will Love

<BulletPointsCard
  bulletStyle="check"
  divider={false}
  title="What you'll actually build:"
  bullets={[
    {
      title: "Type-safe endpoints with auto-validation & OpenAPI docs",
      description: "Request/response models that match your frontend, with automatic OpenAPI docs generation",
    },
    {
      title: "SQL in actual code",
      description: "Write TypeScript/Python functions instead of Jinja templates for more expressiveness",
    },
    {
      title: "Direct table references",
      description: "Import tables for autocompletion & type safety",
    },
    {
      title: "Built-in security",
      description: "JWT validation and SQL injection protection",
    },
  ]}
/>

<Callout type="info" title="Learn More">
See the [Consumption APIs docs](/moose/building/consumption-apis) for authentication, query patterns, and examples.
</Callout>


### 4. Use AI to Generate Analytics & APIs

<Callout type="info" title="Try Aurora">
Want AI to generate insights and APIs from your data? Try [Aurora](/aurora/quickstart) - our AI analytics agent for Moose projects.
</Callout>

## Current Limitations

### What doesn't work yet
- **Selective table import**: Imports all tables (filtering coming soon)
- **Custom ClickHouse functions**: Default values with functions get stripped
- **Advanced ClickHouse types**: These aren't supported yet:
  - `Map(K, V)` types
  - `Tuple(T1, T2, ...)` types  
  - `Geo` types (Point, Ring, Polygon, etc.)

<Callout type="warning" title="Skipped tables">
Right now, tables featuring these types will be skipped during the initialization process.
</Callout>

### Partially supported types
  - `LowCardinality(T)` → maps to base type `T`
  - `JSON` types → `any` (Python) / `Record<string, any>` (TypeScript)
  - `Enum` types

<Callout type="info" title="Minor edge cases">
These types are supported but may need manual type adjustments in generated code.
</Callout>