---
title: Summary
description: Summary of deploying Moose into production
---

import { TypeScript, Python, LanguageSwitcher } from "@/components";

# Deploying Moose into Production
<LanguageSwitcher />

Once you've finished developing your Moose application locally, the next step is to deploy your Moose app into production. Check out the Architecture page to see what the architecture of your Moose application in production will look like.

Moose makes it easy to package and deploy your applications, whether you're deploying to a server with or without internet access. The deployment process is designed to be flexible and can accommodate both containerized and non-containerized environments.

## Key Deployment Steps

There are three main aspects to deploying a Moose application:

<TypeScript>
1. Setting up your build environment with Node.js and the Moose CLI
2. Building your application using `moose build`
3. Setting up your deployment environment with the necessary runtime dependencies (Node.js, Docker) and configuration
</TypeScript>

<Python>
1. Setting up your build environment with Python and the Moose CLI
2. Building your application using `moose build`
3. Setting up your deployment environment with the necessary runtime dependencies (Python, Docker) and configuration
</Python>

## Deployment Options

Moose supports several deployment scenarios:

1. **Kubernetes Deployment**: Deploy your application to Kubernetes clusters (GKE, EKS, AKS, or on-premises)
2. **Standard Server Deployment**: Deploy your application to a server with internet access
3. **Containerized Cloud Deployment**: Deploy to cloud services like AWS ECS or Google Cloud Run
4. **Offline Server Deployment**: Deploy to an environment without internet access

## Production-Ready Configuration

Based on our production experience, we recommend the following best practices for deploying Moose applications:

### Health Monitoring

Configure comprehensive health checks to ensure your application remains available:
- Startup probes to handle initialization
- Readiness probes for traffic management
- Liveness probes to detect and recover from deadlocks

### Zero-Downtime Deployments

Implement graceful termination and rolling updates:
- Pre-stop hooks to handle in-flight requests
- Appropriate termination grace periods
- Rolling update strategies that maintain service availability

### Resource Allocation

Properly size your deployments based on workload:
- CPU and memory requests tailored to your application
- Replicas scaled according to traffic patterns
- Horizontal scaling for high availability

### Environment Configuration

For any deployment type, you'll need to configure:

1. Runtime environment variables for logging, telemetry, and application settings
2. External service connections (Clickhouse, Redpanda, Redis)
3. Network settings and security configurations
4. Application-specific configurations

## Detailed Guides

The following pages provide detailed guides for each deployment scenario, including step-by-step instructions for both Python and TypeScript applications and production-ready configuration templates.
