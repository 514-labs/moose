{"version":3,"file":"utils.js","sourceRoot":"","sources":["../app/scripts/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,sCAAwC;AAExC,qCAAyB;AACzB,yCAA6B;AAE7B,6CAAiC;AAEjC,4CAA4C;AAC5C,MAAM,CAAC,MAAM,EAAE,CAAC;AAEhB,0CAA0C;AAC7B,QAAA,OAAO,GAAG,IAAI,cAAO,EAAE,CAAC;AAuBxB,QAAA,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,MAAM,EAAE,kBAAkB,CAAC,CAAC;AAEnF,mCAAmC;AAC5B,IAAM,aAAa,GAAG;IAC3B,IAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,MAAM,CAAC,CAAC;IACjD,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC;QAC5B,EAAE,CAAC,SAAS,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IAC7C,CAAC;AACH,CAAC,CAAC;AALW,QAAA,aAAa,iBAKxB;AAEF,mCAAmC;AAC5B,IAAM,QAAQ,GAAG;IACtB,IAAI,CAAC;QACH,IAAI,EAAE,CAAC,UAAU,CAAC,sBAAc,CAAC,EAAE,CAAC;YAClC,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,YAAY,CAAC,sBAAc,EAAE,MAAM,CAAC,CAAC,CAAC;YACjE,OAAO,IAAI,CAAC,IAAI,CAAC;QACnB,CAAC;IACH,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,IAAI,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;IAC9C,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAVW,QAAA,QAAQ,YAUnB;AAEF,oBAAoB;AACb,IAAM,QAAQ,GAAG,UAAC,IAAY;IACnC,IAAI,CAAC;QACH,IAAA,qBAAa,GAAE,CAAC;QAChB,EAAE,CAAC,aAAa,CAAC,sBAAc,EAAE,IAAI,CAAC,SAAS,CAAC;YAC9C,IAAI,MAAA;YACJ,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;SAClC,CAAC,CAAC,CAAC;IACN,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;IAC/C,CAAC;AACH,CAAC,CAAC;AAVW,QAAA,QAAQ,YAUnB;AAEF,8CAA8C;AACvC,IAAM,aAAa,GAAG;IAC3B,OAAO,IAAI,cAAO,CAAC;QACjB,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC,YAAY;KAC/B,CAAC,CAAC;AACL,CAAC,CAAC;AAJW,QAAA,aAAa,iBAIxB","sourcesContent":["import { Octokit } from \"@octokit/rest\";\nimport { GetResponseDataTypeFromEndpointMethod, GetResponseTypeFromEndpointMethod, Endpoints } from \"@octokit/types\";\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { cliLog } from \"@514labs/moose-lib\";\nimport * as dotenv from 'dotenv';\n\n// Load environment variables from .env file\ndotenv.config();\n\n// Initialize Octokit for type definitions\nexport const octokit = new Octokit();\n\n// Export these types so they can be imported by other files\nexport type EventResponseType = GetResponseTypeFromEndpointMethod<typeof octokit.rest.activity.listPublicEvents>;\nexport type EventType = GetResponseDataTypeFromEndpointMethod<typeof octokit.rest.activity.listPublicEvents>;\nexport type EventRequestOptions = Endpoints['GET /events']['parameters'] & {\n  headers?: {\n    'If-None-Match'?: string;\n  }\n};\n\nexport type RepoResponseType = GetResponseTypeFromEndpointMethod<typeof octokit.rest.repos.get>;\nexport type RepoType = GetResponseDataTypeFromEndpointMethod<typeof octokit.rest.repos.get>;\nexport type RepoRequestOptions = Endpoints['GET /repos/{owner}/{repo}']['parameters'];\n\n// Define the output interface that will be shared with other tasks\nexport interface FetchEventsOutput {\n  events: EventType;\n  fetchedAt: string;\n  count: number;\n  noNewEvents: boolean;\n}\n\nexport const ETAG_FILE_PATH = path.join(process.cwd(), 'data', 'github_etag.json');\n\n// Ensure the data directory exists\nexport const ensureDataDir = () => {\n  const dataDir = path.join(process.cwd(), 'data');\n  if (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n  }\n};\n\n// Load etag from file if it exists\nexport const loadEtag = (): string | null => {\n  try {\n    if (fs.existsSync(ETAG_FILE_PATH)) {\n      const data = JSON.parse(fs.readFileSync(ETAG_FILE_PATH, 'utf8'));\n      return data.etag;\n    }\n  } catch (error) {\n    console.warn('Failed to load etag:', error);\n  }\n  return null;\n};\n\n// Save etag to file\nexport const saveEtag = (etag: string): void => {\n  try {\n    ensureDataDir();\n    fs.writeFileSync(ETAG_FILE_PATH, JSON.stringify({ \n      etag, \n      updated: new Date().toISOString() \n    }));\n  } catch (error) {\n    console.error('Failed to save etag:', error);\n  }\n};\n\n// Create a new authenticated Octokit instance\nexport const createOctokit = () => {\n  return new Octokit({\n    auth: process.env.GITHUB_TOKEN,\n  });\n}; "]}