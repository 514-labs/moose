use serde::Serialize;
use std::collections::HashMap;

use tinytemplate::TinyTemplate;

use super::generator::{InterfaceField, TypescriptInterface, TypescriptObjects, TypescriptPackage};

pub static INTERFACE_TEMPLATE: &str = r#"

// ==================================================================================================
// |      WARNING: This file is generated by the framework. Do NOT modify this file directly.        |
// | This file will be removed in future releases that will use typescript as a modeling language.   |
// ==================================================================================================

export interface {name} \{
    {{for field in fields}}{field.name}{{if field.is_optional}}?{{endif}}: {field.field_type}, 
    {{endfor}}
}
"#;

#[derive(Serialize)]
struct InterfaceContext {
    name: String,
    file_name: String,
    var_name: String,
    fields: Vec<InterfaceFieldContext>,
}

impl InterfaceContext {
    fn new(interface: &TypescriptInterface) -> InterfaceContext {
        InterfaceContext {
            name: interface.name.clone(),
            file_name: interface.file_name(),
            var_name: interface.var_name(),
            fields: interface
                .fields
                .clone()
                .into_iter()
                .map(InterfaceFieldContext::new)
                .collect::<Vec<InterfaceFieldContext>>(),
        }
    }
}

#[derive(Serialize)]
struct InterfaceFieldContext {
    name: String,
    field_type: String,
    is_optional: bool,
}

impl InterfaceFieldContext {
    fn new(interface_field: InterfaceField) -> InterfaceFieldContext {
        InterfaceFieldContext {
            name: interface_field.name,
            field_type: interface_field.field_type.to_string(),
            is_optional: interface_field.is_optional,
        }
    }
}

pub struct InterfaceTemplate;

impl InterfaceTemplate {
    pub fn build(interface: &TypescriptInterface) -> String {
        let mut tt = TinyTemplate::new();
        tt.add_template("interface", INTERFACE_TEMPLATE).unwrap();
        let context = InterfaceContext::new(interface);

        tt.render("interface", &context).unwrap()
    }
}

pub static SEND_FUNC_TEMPLATE: &str = r#"import \{ {interface_context.name} } from './{interface_context.file_name}';

export async function {declaration_name}({interface_context.var_name}: {interface_context.name}) \{
    return fetch('{server_url}/{api_route_name}', \{
        method: 'POST',
        mode: 'no-cors',
        headers: \{
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({interface_context.var_name})
    })
}
"#;

#[derive(Serialize)]
pub struct SendFunctionContext {
    interface_context: InterfaceContext,
    declaration_name: String,
    file_name: String,
    server_url: String,
    api_route_name: String,
}

impl SendFunctionContext {
    fn new(
        interface: &TypescriptInterface,
        server_url: String,
        api_route_name: String,
    ) -> SendFunctionContext {
        SendFunctionContext {
            interface_context: InterfaceContext::new(interface),
            declaration_name: interface.send_function_name(),
            file_name: interface.send_function_file_name(),
            server_url,
            api_route_name,
        }
    }
}

pub struct SendFunctionTemplate;

impl SendFunctionTemplate {
    pub fn build(
        interface: &TypescriptInterface,
        server_url: String,
        api_route_name: String,
    ) -> String {
        let mut tt = TinyTemplate::new();
        tt.add_template("send", SEND_FUNC_TEMPLATE).unwrap();
        let context = SendFunctionContext::new(interface, server_url, api_route_name);

        tt.render("send", &context).unwrap()
    }
}

pub static INDEX_TEMPLATE: &str = r#"{{- for ts_object in ts_objects}}
import \{ {ts_object.interface_context.name} } from './{latest_version}/{ts_object.interface_context.name}';
import \{ {ts_object.send_function_context.declaration_name} } from './{latest_version}/{ts_object.send_function_context.file_name}';
{{endfor}}

{{for ts_object in ts_objects}}
export \{ {ts_object.interface_context.name} };
export \{ {ts_object.send_function_context.declaration_name} };
{{- endfor}}
"#;

#[derive(Serialize)]
struct TypescriptObjectsContext {
    interface_context: InterfaceContext,
    send_function_context: SendFunctionContext,
}

impl TypescriptObjectsContext {
    fn new(ts_objects: &TypescriptObjects) -> TypescriptObjectsContext {
        TypescriptObjectsContext {
            interface_context: InterfaceContext::new(&ts_objects.interface),
            send_function_context: SendFunctionContext::new(
                &ts_objects.interface,
                ts_objects.send_function.server_url.clone(),
                ts_objects.send_function.api_route_name.clone(),
            ),
        }
    }
}

#[derive(Serialize)]
struct IndexContext {
    latest_version: String,
    ts_objects: Vec<TypescriptObjectsContext>,
}
impl IndexContext {
    fn new(
        latest_version: String,
        ts_objects: &HashMap<String, TypescriptObjects>,
    ) -> IndexContext {
        IndexContext {
            latest_version,
            ts_objects: ts_objects
                .values()
                .map(TypescriptObjectsContext::new)
                .collect::<Vec<TypescriptObjectsContext>>(),
        }
    }
}
pub struct IndexTemplate;

impl IndexTemplate {
    pub fn build(
        latest_version: &str,
        latest_objects: &HashMap<String, TypescriptObjects>,
    ) -> String {
        let mut tt = TinyTemplate::new();
        tt.add_template("index", INDEX_TEMPLATE).unwrap();
        let context = IndexContext::new(latest_version.to_string(), latest_objects);

        tt.render("index", &context).unwrap()
    }
}

pub static PACKAGE_JSON_TEMPLATE: &str = r#"
\{
    "name": "{package_name}",
    "version": "0.0.0",
    "description": "",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": \{
        "build": "tsc --build",
        "clean": "tsc --build --clean"
      },
    "keywords": [],
    "author": "moose-cli",
    "license": "ISC",
    "devDependencies": \{
        "@types/node": "^18.*.*",
        "typescript": "^5.*.*"
    },
    "dependencies": \{

    }
}
"#;

#[derive(Serialize)]
pub struct PackageJsonContext {
    package_name: String,
    // package_version: String,
    // package_author: String,
}

impl PackageJsonContext {
    fn new(package_name: String) -> PackageJsonContext {
        PackageJsonContext {
            package_name,
            // package_version,
            // package_author,
        }
    }
}

pub struct PackageJsonTemplate;

impl PackageJsonTemplate {
    pub fn build(package: &TypescriptPackage) -> String {
        let mut tt = TinyTemplate::new();
        tt.add_template("package_json", PACKAGE_JSON_TEMPLATE)
            .unwrap();
        let context = PackageJsonContext::new(package.name.clone());

        tt.render("package_json", &context).unwrap()
    }
}

// I'm using the same pattern since we may want to allow the user to configure this in the future.
pub static TS_CONFIG_TEMPLATE: &str = r#"
\{
    "compilerOptions": \{
        "target": "ES2017",
        "module": "esnext",
        "moduleResolution": "node",
        "lib": ["es6"],
        "strict": true,
        "declaration": true,
        "removeComments": false,
        "outDir": "./dist",
    }
}
"#;

#[derive(Serialize)]
pub struct TsConfigContext;

impl TsConfigContext {
    fn new() -> TsConfigContext {
        TsConfigContext
    }
}

pub struct TsConfigTemplate;

impl TsConfigTemplate {
    pub fn build() -> String {
        let mut tt = TinyTemplate::new();
        tt.add_template("ts_config", TS_CONFIG_TEMPLATE).unwrap();
        let context = TsConfigContext::new();

        tt.render("ts_config", &context).unwrap()
    }
}
