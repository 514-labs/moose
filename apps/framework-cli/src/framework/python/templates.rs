//! # Python Templates
//! This module provides template strings and rendering functionality for Python project files.
//!
//! ## Template Types
//! The module includes templates for:
//! - Project configuration (setup.py)
//! - Data models
//! - Streaming functions
//! - API endpoints
//! - Consumption patterns
//!
//! ## Template Rendering
//! Templates are rendered using the Handlebars templating engine, with context
//! provided by the PythonProject structure.
//!
//! ## Usage
//! Templates are used during project creation and updates to generate consistent
//! Python code structures across the application.

use handlebars::Handlebars;

use crate::project::python_project::PythonProject;

/// Errors that can occur during Python template rendering
#[derive(Debug, thiserror::Error)]
#[error("Failed to generate Python code")]
#[non_exhaustive]
pub enum PythonRenderingError {
    /// Error occurred in the Handlebars template engine
    HandlebarError(#[from] handlebars::RenderError),
}

/// Template for basic Python data models
///
/// Includes example models with various field types and decorators
pub static PYTHON_BASE_MODEL_TEMPLATE: &str = r#"
# This file was auto-generated by the framework. You can add data models or change the existing ones

from moose_lib import Key, moose_data_model
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

# This decorator is used to mark the data model as a Moose data model
@moose_data_model
@dataclass
class Foo:
    primary_key: Key[str]
    timestamp: float
    optional_text: Optional[str]

@moose_data_model
@dataclass
class Bar:
    primary_key: Key[str]
    utc_timestamp: datetime
    has_text: bool
    text_length: int
"#;

/// Template for setup.py configuration file
///
/// Generates a setup.py that reads dependencies from requirements.txt
/// and configures basic project metadata.
pub static SETUP_PY_TEMPLATE: &str = r#"
from setuptools import setup

with open('requirements.txt') as f:
    requirements = [line.strip() for line in f if line.strip() and not line.startswith('#')]

setup(
    name='{{name}}',
    version='{{version}}',
    install_requires=requirements,
    python_requires='{{python_requires}}',
)
"#;

/// Template for streaming function implementation
///
/// Provides an example of data transformation between two models
pub static PYTHON_BASE_STREAMING_FUNCTION_SAMPLE: &str = r#"
## Example Streaming Function: Transforms Foo data to Bar data

from moose_lib import StreamingFunction
from app.datamodels.models import Foo, Bar # Import your Moose data models to use in the streaming function
from datetime import datetime

# The 'run' function contains the logic that runs on each new data point in the Foo stream.
# For more details on how Moose streaming functions work, see: https://docs.moosejs.com
def run(foo: Foo) -> Bar:
    return Bar(
        primary_key=foo.primary_key,
        utc_timestamp=datetime.fromtimestamp(foo.timestamp),
        has_text=foo.optional_text is not None,
        text_length=len(foo.optional_text) if foo.optional_text else 0
    )

Foo__Bar = StreamingFunction(run=run) # Register the run function as a streaming function.
"#;

/// Template for creating new streaming functions
///
/// Generates a basic streaming function structure with customizable
/// source and destination types
pub static PYTHON_BASE_STREAMING_FUNCTION_TEMPLATE: &str = r#"
# Import your Moose data models to use in the streaming function
{{source_import}}
{{destination_import}}
from moose_lib import StreamingFunction
from typing import Optional
from datetime import datetime

def fn(source: {{source}}) -> Optional[{{destination}}]:
    return {{destination_object}}

my_function = StreamingFunction(
    run=fn
)
"#;

/// Template for data consumption endpoints
///
/// Creates a basic structure for consuming data with query parameters
pub static PYTHON_BASE_CONSUMPTION_TEMPLATE: &str = r#"
# This file is where you can define your API templates for consuming your data
#Query params are passed in as Pydantic models and are used within the sql tag to parameterize you queries

from moose_lib import MooseClient
from pydantic import BaseModel

class QueryParams(BaseModel):
    limit: Optional[int] = 10

def run(client: MooseClient, params: QueryParams):
    return client.query.execute("SELECT 1", {})
"#;

/// Template for API implementation
///
/// Provides a comprehensive example of API endpoint implementation
/// with query parameters and data access
pub static PYTHON_BASE_API_SAMPLE: &str = r#"

# This file is where you can define your API templates for consuming your data

from moose_lib import MooseClient
from pydantic import BaseModel, Field
from typing import Optional

# Query params are defined as Pydantic models and are validated automatically
class QueryParams(BaseModel):
    order_by: Optional[str] = Field(
        default="total_rows",
        pattern=r"^(total_rows|rows_with_text|max_text_length|total_text_length)$",
        description="Must be one of: total_rows, rows_with_text, max_text_length, total_text_length"
    )
    limit: Optional[int] = Field(
        default=5,
        gt=0,
        le=100,
        description="Must be between 1 and 100"
    )
    start_day: Optional[int] = Field(
        default=1,
        gt=0,
        le=31,
        description="Must be between 1 and 31"
    )
    end_day: Optional[int] = Field(
        default=31,
        gt=0,
        le=31,
        description="Must be between 1 and 31"
    )
    
## The run function is where you can define your API logic
def run(client: MooseClient, params: QueryParams):
    
    start_day = params.start_day
    end_day = params.end_day
    limit = params.limit
    order_by = params.order_by
    
    query = f"""
    SELECT 
        day_of_month,
        {order_by}
    FROM BarAggregated_MV 
    WHERE day_of_month >= {start_day} 
    AND day_of_month <= {end_day} 
    ORDER BY {order_by} DESC
    LIMIT {limit}
    """    
   
    return client.query.execute(query, {"order_by": order_by, "start_day": start_day, "end_day": end_day, "limit": limit})

"#;

pub static PYTHON_BASE_SCRIPT_TEMPLATE: &str = r#"from moose_lib import task

@task()
def {{name}}(input: dict):  # The name of your script
    """
    Description of what this script does
    """
    # The body of your script goes here

    # The return value is the output of the script.
    # The return value should be a dictionary with at least:
    # - task: the task name (e.g., "extract", "transform")
    # - data: the actual data being passed to the next task
    return {
        "task": "{{name}}",  # The task name is the name of the script
        "data": None     # The data being passed to the next task (4MB limit)
    }
"#;

/// Renders the setup.py template with project configuration
///
/// # Arguments
/// * `project` - Project configuration containing name, version, and dependencies
///
/// # Returns
/// * `Result<String, PythonRenderingError>` - Rendered setup.py content or an error
///
/// # Errors
/// * `HandlebarError` if template rendering fails
pub fn render_setup_py(project: PythonProject) -> Result<String, PythonRenderingError> {
    let reg = Handlebars::new();

    let template_context = serde_json::json!({
        "name": project.name,
        "version": project.version,
        "dependencies": project.dependencies,
        "python_requires": project.python_requires,
    });

    Ok(reg.render_template(SETUP_PY_TEMPLATE, &template_context)?)
}
