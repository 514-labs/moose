---
title: Moose APIs
description: Create type-safe ingestion and consumption APIs for data access and integration
---

import { Callout, LanguageSwitcher, BulletPointsCard, CheckmarkBullets, TypeScript, Python, CTACards, CTACard } from "@/components";
import { Tabs } from "nextra/components";

# APIs
<LanguageSwitcher />

## Overview

The APIs capability provides standalone HTTP endpoints for data ingestion and consumption. Unlike other modules of the MooseStack, APIs are meant to be paired with other MooseStack modules like OLAP tables and streams.


## Core Capabilities

<CTACards>
<CTACard
  title="Ingest Data"
  description="Create HTTP POST endpoints for data ingestion with validation and routing"
  ctaLink="/stack/apis/ingest-data"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "Ingestion" }}
/>
<CTACard
  title="Egress Data"
  description="Create HTTP GET endpoints for data consumption with query parameters"
  ctaLink="/stack/apis/egress-data"
  ctaLabel="Learn More →"
  badge={{ variant: "moose", text: "Consumption" }}
/>
</CTACards>

## Basic Examples

### Ingestion API

<TypeScript>
```ts filename="IngestApi.ts" copy
import { IngestApi } from "@514labs/moose-lib";

interface UserEvent {
  id: string;
  userId: string;
  timestamp: Date;
  eventType: string;
}

// Create a standalone ingestion API
const userEventsApi = new IngestApi<UserEvent>("user-events", {
  destination: eventStream
});
```
</TypeScript>

<Python>
```py filename="IngestApi.py" copy
from moose_lib import IngestApi
from pydantic import BaseModel
from datetime import datetime

class UserEvent(BaseModel):
    id: str
    user_id: str
    timestamp: datetime
    event_type: str

# Create a standalone ingestion API
user_events_api = IngestApi[UserEvent]("user-events", IngestConfig(destination=event_stream))
```
</Python>

### Query API

<TypeScript>
```ts filename="QueryApi.ts" copy
import { QueryApi } from "@514labs/moose-lib";

interface Params {
  userId: string;
  limit: number;
}

interface ResultData {
  id: string;
  name: string;
  email: string;
}

// Create a standalone consumption API
const userDataApi = new QueryApi<Params, ResultData[]>("user-data", 
  async ({ userId, limit }, { client, sql }) => {
    // Query external service or custom logic
    return [
      { id: userId, name: "John Doe", email: "john@example.com" }
    ];
  }
);
```
</TypeScript>

<Python>
```py filename="ConsumptionApi.py" copy
from moose_lib import ConsumptionApi, MooseClient
from pydantic import BaseModel

class Params(BaseModel):
    user_id: str
    limit: int

class ResultData(BaseModel):
    id: str
    name: str
    email: str

def query_function(client: MooseClient, params: QueryParams) -> list[UserData]:
    # Query external service or custom logic
    sql = f"SELECT * FROM user_data WHERE user_id = {params.user_id} LIMIT {params.limit}"
    return client.query.execute(sql)

user_data_api = QueryApi[Params, ResultData]("get-data", query_function)
```
</Python>

## When to Use Moose APIs vs. Existing Backends

If you already have a FastAPI, Fastify, or other REST API backend and are using Moose OLAP and streaming modules, here's when to use Moose APIs versus integrating Moose functions into your existing backend:

### Use Moose APIs When:

- You need a standalone analytical backend service or microservice
- You need to handle high-throughput data ingestion (Rust-level performance)
- You want built in schema validation and Dead Letter Queue support
- You want to re-use your table or stream schemas for API validation


### Integrate Moose Functions into Existing Backend When:

- You need to reuse your existing authentication middleware (JWT, OAuth, etc.)
- You want to maintain consistent API patterns across your application (error handling, response formats, etc.)

### Custom Webhook Authentication
Moose Ingest APIs don't support custom authentication logic for third-party webhooks (e.g., GitHub webhooks with signature verification, Stripe webhooks with signing secrets).

You can use your existing API framework to handle webhook authentication, then use MooseClient to insert validated data into ClickHouse. See the [Client Integrations](/stack/open-api) page for more information.