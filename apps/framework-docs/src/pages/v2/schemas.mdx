import { Callout, LanguageSwitcher, TypeScript, Python } from "../../components";
import { FileTree, Tabs } from "nextra/components";

# Schema Design

<LanguageSwitcher />

Moose uses strongly-typed schemas to define your data models, providing type safety and automatic validation. These schemas serve as the blueprint for your application's data architecture, from which Moose derives the underlying infrastructure including REST APIs, streaming topics, and storage tables.

## Basic Types

<TypeScript>
```typescript
import { Key } from "@514labs/moose-lib";

export interface BasicDataModel {
  // Required: Primary key for your data model
  primaryKey: Key<string>;    // string key
  // or
  numericKey: Key<number>;    // numeric key

  // Common types
  someString: string;         // Text
  someNumber: number;         // Numbers
  someBoolean: boolean;       // Boolean
  someDate: Date;            // Timestamps
  someArray: string[];       // Arrays
  someObject: object;        // Objects
}
```
</TypeScript>

<Python>
```python
from moose_lib import Key, moose_data_model
from dataclasses import dataclass
from datetime import datetime
from typing import List

@moose_data_model
@dataclass
class BasicDataModel:
    primary_key: Key[str]      # string key
    # or
    numeric_key: Key[int]      # numeric key
    
    # Common types
    some_string: str           # Text
    some_number: int           # Numbers
    some_boolean: bool         # Boolean
    some_date: datetime        # Timestamps
    some_array: List[str]      # Arrays
```
</Python>

## Nested Objects

<TypeScript>
```typescript
import { Key } from "@514labs/moose-lib";

// Define nested object separately
interface NestedObject {
  nestedNumber: number;
  nestedBoolean: boolean;
  nestedArray: number[];
}

export interface DataModelWithNested {
  primaryKey: Key<string>;
  
  // Reference nested object
  nestedData: NestedObject;

  // Or define inline
  inlineNested: {
    someValue: string;
    someOtherValue: number;
  };
}
```
</TypeScript>

<Python>
```python
from moose_lib import Key, moose_data_model
from dataclasses import dataclass
from typing import List

@dataclass
class NestedObject:
    nested_number: int
    nested_boolean: bool
    nested_array: List[int]

@moose_data_model
@dataclass
class DataModelWithNested:
    primary_key: Key[str]
    nested_data: NestedObject
```
</Python>

## Type Mapping

The table below shows the supported field types and how Moose maps them to ClickHouse:

<TypeScript>
| TypeScript | ClickHouse | Description |
|------------|------------|-------------|
| `string` | String | Text values |
| `number` | Float64 | Numeric values |
| `number & tags.Type<"int64">` | Int64 | Integer values |
| `boolean` | Boolean | True/false values |
| `Date` | DateTime | Timestamp values |
| `Array` | Array | Lists of values |
| `object` | Nested | Nested structures |
| `Enum` | Enum | Enumerated values |
</TypeScript>

<Python>
| Python | ClickHouse | Description |
|--------|------------|-------------|
| `str` | String | Text values |
| `int` | Int64 | Integer values |
| `float` | Float64 | Decimal values |
| `bool` | Boolean | True/false values |
| `datetime` | DateTime | Timestamp values |
| `List[T]` | Array | Lists of values |
| `Enum` | Enum | Enumerated values |
</Python>

## Best Practices

### Use Clear Names and Types

<TypeScript>
```typescript
// ❌ Avoid unclear names
export interface Data {
  id: Key<string>;
  ts: Date;
  val: number;
}

// ✅ Use descriptive names
export interface PageViewMetric {
  pageId: Key<string>;
  timestamp: Date;
  duration: number;
}
```
</TypeScript>

<Python>
```python
# ❌ Avoid unclear names
@moose_data_model
@dataclass
class Data:
    id: Key[str]
    ts: datetime
    val: float

# ✅ Use descriptive names
@moose_data_model
@dataclass
class PageViewMetric:
    page_id: Key[str]
    timestamp: datetime
    duration: float
```
</Python>

### Use Enums for Fixed Values

<TypeScript>
```typescript
import { Key } from "@514labs/moose-lib";

enum OrderStatus {
  PENDING = "pending",
  PROCESSING = "processing",
  COMPLETED = "completed"
}

export interface Order {
  orderId: Key<string>;
  status: OrderStatus;
  createdAt: Date;
}
```
</TypeScript>

<Python>
```python
from enum import Enum
from moose_lib import Key, moose_data_model
from dataclasses import dataclass
from datetime import datetime

class OrderStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"

@moose_data_model
@dataclass
class Order:
    order_id: Key[str]
    status: OrderStatus
    created_at: datetime
```
</Python>

<Callout type="info" title="Schema Evolution">
When evolving your schemas, follow these guidelines:
- Add new fields as optional to maintain backward compatibility
- Avoid removing or renaming existing fields
- Consider creating a new version of your model for major changes
</Callout>

## Complex Types

```typescript
interface ComplexRecord {
  id: Key<string>;
  
  // Nested objects
  user: {
    id: string;
    name: string;
    email: string;
  };

  // Arrays of objects
  items: Array<{
    id: string;
    quantity: number;
    price: number;
  }>;

  // Optional fields
  description?: string;
  
  // Union types
  status: 'pending' | 'active' | 'completed';
  
  // Record types
  metadata: Record<string, string>;
}
```

## Type Mapping

DMv2 automatically maps TypeScript types to the appropriate storage types:

| TypeScript Type | ClickHouse Type | JSON Schema Type |
|----------------|-----------------|------------------|
| `string` | `String` | `string` |
| `number` | `Float64` | `number` |
| `boolean` | `UInt8` | `boolean` |
| `Date` | `DateTime64(3)` | `string` (ISO format) |
| `string[]` | `Array(String)` | `array` |
| `number[]` | `Array(Float64)` | `array` |
| `object` | `JSON` | `object` |
| `Record<K,V>` | `JSON` | `object` |

## Best Practices

### 1. Use Clear Names

```typescript
// ❌ Bad
interface Data {
  id: Key<string>;
  ts: Date;
  val: number;
}

// ✅ Good
interface PageViewMetric {
  id: Key<string>;
  timestamp: Date;
  duration: number;
}
```

### 2. Group Related Fields

```typescript
// ❌ Bad
interface UserEvent {
  id: Key<string>;
  userId: string;
  userName: string;
  userEmail: string;
  eventType: string;
  eventTime: Date;
}

// ✅ Good
interface UserEvent {
  id: Key<string>;
  user: {
    id: string;
    name: string;
    email: string;
  };
  event: {
    type: string;
    timestamp: Date;
  };
}
```

### 3. Use Enums for Fixed Values

```typescript
// Define the enum
enum OrderStatus {
  Pending = 'pending',
  Processing = 'processing',
  Completed = 'completed',
  Cancelled = 'cancelled'
}

// Use in interface
interface Order {
  id: Key<string>;
  status: OrderStatus;  // Type-safe status values
  items: OrderItem[];
}
```

### 4. Include Metadata

```typescript
interface EventBase {
  id: Key<string>;
  timestamp: Date;
  
  // Common metadata
  metadata: {
    source: string;
    version: string;
    environment: 'dev' | 'staging' | 'prod';
  };
}

// Extend base interface
interface UserEvent extends EventBase {
  userId: string;
  action: string;
}
```

## Validation

DMv2 automatically validates data at ingestion points:

```typescript
interface UserProfile {
  id: Key<string>;
  email: string;
  age: number;
  preferences: string[];
}

// Validation examples:
const valid = {
  id: "user123",
  email: "user@example.com",
  age: 25,
  preferences: ["dark-mode", "notifications"]
};  // ✅ Valid

const invalid = {
  id: "user123",
  email: "not-an-email",
  age: "25",  // ❌ Type error: string instead of number
  preferences: "dark-mode"  // ❌ Type error: string instead of array
};
```

## Schema Evolution

DMv2 supports schema evolution with backward compatibility:

```typescript
// Original schema
interface UserV1 {
  id: Key<string>;
  name: string;
}

// Updated schema
interface UserV2 {
  id: Key<string>;
  name: string;
  email?: string;  // Optional new field
  // Remove fields with care!
}
```

## Next Steps

- Learn about [Storage with OlapTable](/v2/data-modeling/olap-table)
- Explore [Stream Processing](/v2/data-modeling/streams)
- Read about [Data Ingestion](/v2/data-modeling/ingestion)
- Check [Best Practices](/v2/data-modeling/best-practices) 