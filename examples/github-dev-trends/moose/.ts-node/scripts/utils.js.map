{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../app/scripts/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Octokit } from \"@octokit/rest\";\nimport {\n  GetResponseDataTypeFromEndpointMethod,\n  GetResponseTypeFromEndpointMethod,\n  Endpoints,\n} from \"@octokit/types\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { cliLog } from \"@514labs/moose-lib\";\nimport * as dotenv from \"dotenv\";\nimport { graphql } from \"@octokit/graphql\";\n\n// Load environment variables from .env file\ndotenv.config();\n\n// Initialize Octokit for type definitions\nexport const octokit = new Octokit();\n\n// Export these types so they can be imported by other files\nexport type EventResponseType = GetResponseTypeFromEndpointMethod<\n  typeof octokit.rest.activity.listPublicEvents\n>;\nexport type EventType = GetResponseDataTypeFromEndpointMethod<\n  typeof octokit.rest.activity.listPublicEvents\n>;\nexport type EventRequestOptions = Endpoints[\"GET /events\"][\"parameters\"] & {\n  headers?: {\n    \"If-None-Match\"?: string;\n  };\n};\n\nexport type RepoResponseType = GetResponseTypeFromEndpointMethod<\n  typeof octokit.rest.repos.get\n>;\nexport type RepoType = GetResponseDataTypeFromEndpointMethod<\n  typeof octokit.rest.repos.get\n>;\nexport type RepoRequestOptions =\n  Endpoints[\"GET /repos/{owner}/{repo}\"][\"parameters\"];\n\n// Define the output interface that will be shared with other tasks\nexport interface FetchEventsOutput {\n  events: EventType;\n  fetchedAt: string;\n  count: number;\n  noNewEvents: boolean;\n}\n\nexport const ETAG_FILE_PATH = path.join(\n  process.cwd(),\n  \"data\",\n  \"github_etag.json\",\n);\n\n// Ensure the data directory exists\nexport const ensureDataDir = () => {\n  const dataDir = path.join(process.cwd(), \"data\");\n  if (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n  }\n};\n\n// Load etag from file if it exists\nexport const loadEtag = (): string | null => {\n  try {\n    if (fs.existsSync(ETAG_FILE_PATH)) {\n      const data = JSON.parse(fs.readFileSync(ETAG_FILE_PATH, \"utf8\"));\n      return data.etag;\n    }\n  } catch (error) {\n    console.warn(\"Failed to load etag:\", error);\n  }\n  return null;\n};\n\n// Save etag to file\nexport const saveEtag = (etag: string): void => {\n  try {\n    ensureDataDir();\n    fs.writeFileSync(\n      ETAG_FILE_PATH,\n      JSON.stringify({\n        etag,\n        updated: new Date().toISOString(),\n      }),\n    );\n  } catch (error) {\n    console.error(\"Failed to save etag:\", error);\n  }\n};\n\nexport const createGraphqlClient = () => {\n  return graphql.defaults({\n    headers: {\n      authorization: `token ${process.env.GITHUB_TOKEN}`,\n    },\n  });\n};\n\n// Create a new authenticated Octokit instance\nexport const createOctokit = () => {\n  return new Octokit({\n    auth: process.env.GITHUB_TOKEN,\n  });\n};\n\n// Define the shape of a single repository response\nexport interface GitHubRepository {\n  description: string | null;\n  primaryLanguage: {\n    name: string;\n  } | null;\n  repositoryTopics: {\n    nodes: Array<{\n      topic: {\n        name: string;\n      };\n    }>;\n  };\n  owner: {\n    login: string;\n    id: string;\n    __typename: string;\n    url: string;\n    avatarUrl: string;\n  };\n  stargazerCount: number;\n  forkCount: number;\n  watchers: {\n    totalCount: number;\n  };\n  issues: {\n    totalCount: number;\n  };\n  createdAt: string;\n  homepageUrl: string | null;\n}\n\n// Define the shape of the entire GraphQL response\nexport interface GitHubGraphQLResponse {\n  [key: `repo${number}`]: {\n    repository: GitHubRepository | null;\n  };\n}\n\n// Create a typed GraphQL client\nexport const graphqlWithAuth = graphql.defaults({\n  headers: {\n    authorization: `token ${process.env.GITHUB_TOKEN}`,\n  },\n});\n\n// Helper function to fetch repository data\nexport async function fetchReposBatchWithRetry(\n  repos: Array<{ owner: string; name: string }>,\n  retries = 3\n): Promise<Map<string, GitHubRepository>> {\n  const queryFields = repos\n    .map(\n      (repo, i) => `\n      repo${i}: repository(owner: \"${repo.owner}\", name: \"${repo.name}\") {\n        description\n        primaryLanguage {\n          name\n        }\n        repositoryTopics(first: 10) {\n          nodes {\n            topic {\n              name\n            }\n          }\n        }\n        owner {\n          login\n          id\n          __typename\n          url\n          avatarUrl\n        }\n        stargazerCount\n        forkCount\n        watchers {\n          totalCount\n        }\n        issues(states: OPEN) {\n          totalCount\n        }\n        createdAt\n        homepageUrl\n      }\n    `\n    )\n    .join(\"\\n\");\n\n  const query = `\n    query {\n      ${queryFields}\n    }\n  `;\n\n  for (let attempt = 1; attempt <= retries; attempt++) {\n    try {\n      const response = await graphqlWithAuth<GitHubGraphQLResponse>(query);\n      \n      // Convert response to Map\n      const repoDataMap = new Map<string, GitHubRepository>();\n      \n      Object.entries(response).forEach(([key, data], index) => {\n        if (data.repository) {\n          const fullName = `${repos[index].owner}/${repos[index].name}`;\n          repoDataMap.set(fullName, data.repository);\n        }\n      });\n      \n      return repoDataMap;\n    } catch (error: any) {\n      if (error.status === 403 && attempt < retries) {\n        const waitTime = Math.pow(2, attempt) * 1000;\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n        continue;\n      }\n      throw error;\n    }\n  }\n  throw new Error(\"Max retries exceeded\");\n}\n"]}